{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { getWellKnown } from '../endpoints/well-known.js';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport { getDefaultTokenParams } from './defaultTokenParams.js';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants.js';\nimport PKCE from './pkce.js';\n\nfunction assertPKCESupport(sdk) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n\n    if (!sdk.features.isHTTPS()) {\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n\n    if (!sdk.features.hasTextEncoder()) {\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nasync function validateCodeChallengeMethod(sdk, codeChallengeMethod) {\n  codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n  const wellKnownResponse = await getWellKnown(sdk);\n  var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n\n  if (methods.indexOf(codeChallengeMethod) === -1) {\n    throw new AuthSdkError('Invalid code_challenge_method');\n  }\n\n  return codeChallengeMethod;\n}\n\nasync function preparePKCE(sdk, tokenParams) {\n  let {\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  } = tokenParams;\n  codeChallenge = codeChallenge || sdk.options.codeChallenge;\n\n  if (!codeChallenge) {\n    assertPKCESupport(sdk);\n    codeVerifier = codeVerifier || PKCE.generateVerifier();\n    codeChallenge = await PKCE.computeChallenge(codeVerifier);\n  }\n\n  codeChallengeMethod = await validateCodeChallengeMethod(sdk, codeChallengeMethod);\n  tokenParams = Object.assign(Object.assign({}, tokenParams), {\n    responseType: 'code',\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  });\n  return tokenParams;\n}\n\nasync function prepareTokenParams(sdk) {\n  let tokenParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const defaults = getDefaultTokenParams(sdk);\n  tokenParams = Object.assign(Object.assign({}, defaults), tokenParams);\n\n  if (tokenParams.pkce === false) {\n    return tokenParams;\n  }\n\n  return preparePKCE(sdk, tokenParams);\n}\n\nexport { assertPKCESupport, preparePKCE, prepareTokenParams, validateCodeChallengeMethod };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;AAoBM,SAAUA,iBAAV,CAA4BC,GAA5B,EAA0D;EAC9D,IAAI,CAACA,GAAG,CAACC,QAAJ,CAAaC,eAAb,EAAL,EAAqC;IACnC,IAAIC,YAAY,GAAG,qFAAnB;;IACA,IAAI,CAACH,GAAG,CAACC,QAAJ,CAAaG,OAAb,EAAL,EAA6B;MAE3BD,YAAY,IAAI,kGAAhB;IACD;;IACD,IAAI,CAACH,GAAG,CAACC,QAAJ,CAAaI,cAAb,EAAL,EAAoC;MAElCF,YAAY,IAAI,wGAAhB;IACD;;IACD,MAAM,IAAIG,YAAJ,CAAiBH,YAAjB,CAAN;EACD;AACF;;AAEM,eAAeI,2BAAf,CAA2CP,GAA3C,EAAuEQ,mBAAvE,EAAmG;EAExGA,mBAAmB,GAAGA,mBAAmB,IAAIR,GAAG,CAACS,OAAJ,CAAYD,mBAAnC,IAA0DE,6BAAhF;EAGA,MAAMC,iBAAiB,GAAG,MAAMC,YAAY,CAACZ,GAAD,CAA5C;EACA,IAAIa,OAAO,GAAGF,iBAAiB,CAAC,kCAAD,CAAjB,IAAyD,EAAvE;;EACA,IAAIE,OAAO,CAACC,OAAR,CAAgBN,mBAAhB,MAAyC,CAAC,CAA9C,EAAiD;IAC/C,MAAM,IAAIF,YAAJ,CAAiB,+BAAjB,CAAN;EACD;;EACD,OAAOE,mBAAP;AACD;;AAEM,eAAeO,WAAf,CACLf,GADK,EAELgB,WAFK,EAEmB;EAExB,IAAI;IACFC,YADE;IAEFC,aAFE;IAGFV;EAHE,IAIAQ,WAJJ;EAOAE,aAAa,GAAGA,aAAa,IAAIlB,GAAG,CAACS,OAAJ,CAAYS,aAA7C;;EACA,IAAI,CAACA,aAAL,EAAoB;IAClBnB,iBAAiB,CAACC,GAAD,CAAjB;IACAiB,YAAY,GAAGA,YAAY,IAAIE,IAAI,CAACC,gBAAL,EAA/B;IACAF,aAAa,GAAG,MAAMC,IAAI,CAACE,gBAAL,CAAsBJ,YAAtB,CAAtB;EACD;;EACDT,mBAAmB,GAAG,MAAMD,2BAA2B,CAACP,GAAD,EAAMQ,mBAAN,CAAvD;EAGAQ,WAAW,mCACNA,WADM,GACK;IACdM,YAAY,EAAE,MADA;IAEdL,YAFc;IAGdC,aAHc;IAIdV;EAJc,CADL,CAAX;EAQA,OAAOQ,WAAP;AACD;;AAGM,eAAeO,kBAAf,CACLvB,GADK,EAEwB;EAAA,IAA7BgB,WAA6B,uEAAF,EAAE;EAG7B,MAAMQ,QAAQ,GAAGC,qBAAqB,CAACzB,GAAD,CAAtC;EACAgB,WAAW,GAAQU,2CAAaV,WAAb,CAAnB;;EAEA,IAAIA,WAAW,CAACW,IAAZ,KAAqB,KAAzB,EAAgC;IAE9B,OAAOX,WAAP;EACD;;EAED,OAAOD,WAAW,CAACf,GAAD,EAAMgB,WAAN,CAAlB;AACF","names":["assertPKCESupport","sdk","features","isPKCESupported","errorMessage","isHTTPS","hasTextEncoder","AuthSdkError","validateCodeChallengeMethod","codeChallengeMethod","options","DEFAULT_CODE_CHALLENGE_METHOD","wellKnownResponse","getWellKnown","methods","indexOf","preparePKCE","tokenParams","codeVerifier","codeChallenge","PKCE","generateVerifier","computeChallenge","responseType","prepareTokenParams","defaults","getDefaultTokenParams","Object","pkce"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\jobs-ui\\node_modules\\@okta\\lib\\oidc\\util\\prepareTokenParams.ts"],"sourcesContent":["/* eslint-disable complexity */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { getWellKnown } from '../endpoints/well-known';\nimport { AuthSdkError } from '../../errors';\nimport { OktaAuthFeaturesInterface, OktaAuthOIDCInterface, TokenParams } from '../../types';\nimport { getDefaultTokenParams } from './defaultTokenParams';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants';\nimport PKCE from './pkce';\n\nexport function assertPKCESupport(sdk: OktaAuthFeaturesInterface) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n    if (!sdk.features.isHTTPS()) {\n      // eslint-disable-next-line max-len\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n    if (!sdk.features.hasTextEncoder()) {\n      // eslint-disable-next-line max-len\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nexport async function validateCodeChallengeMethod(sdk: OktaAuthOIDCInterface, codeChallengeMethod?: string) {\n  // set default code challenge method, if none provided\n  codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n\n  // validate against .well-known/openid-configuration\n  const wellKnownResponse = await getWellKnown(sdk);\n  var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n  if (methods.indexOf(codeChallengeMethod) === -1) {\n    throw new AuthSdkError('Invalid code_challenge_method');\n  }\n  return codeChallengeMethod;\n}\n\nexport async function preparePKCE(\n  sdk: OktaAuthOIDCInterface, \n  tokenParams: TokenParams\n): Promise<TokenParams> {\n  let {\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  } = tokenParams;\n\n  // PKCE calculations can be avoided by passing a codeChallenge\n  codeChallenge = codeChallenge || sdk.options.codeChallenge;\n  if (!codeChallenge) {\n    assertPKCESupport(sdk);\n    codeVerifier = codeVerifier || PKCE.generateVerifier();\n    codeChallenge = await PKCE.computeChallenge(codeVerifier);\n  }\n  codeChallengeMethod = await validateCodeChallengeMethod(sdk, codeChallengeMethod);\n\n  // Clone/copy the params. Set PKCE values\n  tokenParams = {\n    ...tokenParams,\n    responseType: 'code', // responseType is forced\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  };\n\n  return tokenParams;\n}\n\n// Prepares params for a call to /authorize or /token\nexport async function prepareTokenParams(\n  sdk: OktaAuthOIDCInterface,\n  tokenParams: TokenParams = {}\n): Promise<TokenParams> {\n  // build params using defaults + options\n  const defaults = getDefaultTokenParams(sdk);\n  tokenParams = { ...defaults, ...tokenParams };\n\n  if (tokenParams.pkce === false) {\n    // Implicit flow or authorization_code without PKCE\n    return tokenParams;\n  }\n\n  return preparePKCE(sdk, tokenParams);\n}"]},"metadata":{},"sourceType":"module"}