{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport PCancelable from 'p-cancelable';\nimport AuthSdkError from './errors/AuthSdkError.js';\nimport './idx/types/api.js';\nimport { EVENT_ADDED, EVENT_REMOVED } from './types/TokenManager.js';\nimport { getConsole } from './util/console.js';\nimport './myaccount/types.js';\nimport PromiseQueue from './PromiseQueue.js';\nvar INITIAL_AUTH_STATE = null;\nvar DEFAULT_PENDING = {\n  updateAuthStatePromise: null,\n  canceledTimes: 0\n};\nvar EVENT_AUTH_STATE_CHANGE = 'authStateChange';\nvar MAX_PROMISE_CANCEL_TIMES = 10;\n\nvar isSameAuthState = function isSameAuthState(prevState, state) {\n  if (!prevState) {\n    return false;\n  }\n\n  return prevState.isAuthenticated === state.isAuthenticated && JSON.stringify(prevState.idToken) === JSON.stringify(state.idToken) && JSON.stringify(prevState.accessToken) === JSON.stringify(state.accessToken) && prevState.error === state.error;\n};\n\nvar AuthStateManager = /*#__PURE__*/function () {\n  function AuthStateManager(sdk) {\n    var _this = this;\n\n    _classCallCheck(this, AuthStateManager);\n\n    if (!sdk.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before AuthStateManager');\n    }\n\n    this._sdk = sdk;\n    this._pending = Object.assign({}, DEFAULT_PENDING);\n    this._authState = INITIAL_AUTH_STATE;\n    this._logOptions = {};\n    this._prevAuthState = null;\n    this._transformQueue = new PromiseQueue({\n      quiet: true\n    });\n    sdk.tokenManager.on(EVENT_ADDED, function (key, token) {\n      _this._setLogOptions({\n        event: EVENT_ADDED,\n        key: key,\n        token: token\n      });\n\n      _this.updateAuthState();\n    });\n    sdk.tokenManager.on(EVENT_REMOVED, function (key, token) {\n      _this._setLogOptions({\n        event: EVENT_REMOVED,\n        key: key,\n        token: token\n      });\n\n      _this.updateAuthState();\n    });\n  }\n\n  _createClass(AuthStateManager, [{\n    key: \"_setLogOptions\",\n    value: function _setLogOptions(options) {\n      this._logOptions = options;\n    }\n  }, {\n    key: \"getAuthState\",\n    value: function getAuthState() {\n      return this._authState;\n    }\n  }, {\n    key: \"getPreviousAuthState\",\n    value: function getPreviousAuthState() {\n      return this._prevAuthState;\n    }\n  }, {\n    key: \"updateAuthState\",\n    value: function () {\n      var _updateAuthState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var _this$_sdk$options, transformAuthState, devMode, log, emitAuthStateChange, finalPromise, cancelablePromise;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$_sdk$options = this._sdk.options, transformAuthState = _this$_sdk$options.transformAuthState, devMode = _this$_sdk$options.devMode;\n\n                log = function log(status) {\n                  var _this2$_logOptions = _this2._logOptions,\n                      event = _this2$_logOptions.event,\n                      key = _this2$_logOptions.key,\n                      token = _this2$_logOptions.token;\n                  getConsole().group(\"OKTA-AUTH-JS:updateAuthState: Event:\".concat(event, \" Status:\").concat(status));\n                  getConsole().log(key, token);\n                  getConsole().log('Current authState', _this2._authState);\n                  getConsole().groupEnd();\n                  _this2._logOptions = {};\n                };\n\n                emitAuthStateChange = function emitAuthStateChange(authState) {\n                  if (isSameAuthState(_this2._authState, authState)) {\n                    devMode && log('unchanged');\n                    return;\n                  }\n\n                  _this2._prevAuthState = _this2._authState;\n                  _this2._authState = authState;\n\n                  _this2._sdk.emitter.emit(EVENT_AUTH_STATE_CHANGE, Object.assign({}, authState));\n\n                  devMode && log('emitted');\n                };\n\n                finalPromise = function finalPromise(origPromise) {\n                  return _this2._pending.updateAuthStatePromise.then(function () {\n                    var curPromise = _this2._pending.updateAuthStatePromise;\n\n                    if (curPromise && curPromise !== origPromise) {\n                      return finalPromise(curPromise);\n                    }\n\n                    return _this2.getAuthState();\n                  });\n                };\n\n                if (!this._pending.updateAuthStatePromise) {\n                  _context.next = 11;\n                  break;\n                }\n\n                if (!(this._pending.canceledTimes >= MAX_PROMISE_CANCEL_TIMES)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                devMode && log('terminated');\n                return _context.abrupt(\"return\", finalPromise(this._pending.updateAuthStatePromise));\n\n              case 10:\n                this._pending.updateAuthStatePromise.cancel();\n\n              case 11:\n                cancelablePromise = new PCancelable(function (resolve, _, onCancel) {\n                  onCancel.shouldReject = false;\n                  onCancel(function () {\n                    _this2._pending.updateAuthStatePromise = null;\n                    _this2._pending.canceledTimes = _this2._pending.canceledTimes + 1;\n                    devMode && log('canceled');\n                  });\n\n                  var emitAndResolve = function emitAndResolve(authState) {\n                    if (cancelablePromise.isCanceled) {\n                      resolve();\n                      return;\n                    }\n\n                    emitAuthStateChange(authState);\n                    resolve();\n                    _this2._pending = Object.assign({}, DEFAULT_PENDING);\n                  };\n\n                  _this2._sdk.isAuthenticated().then(function () {\n                    if (cancelablePromise.isCanceled) {\n                      resolve();\n                      return;\n                    }\n\n                    var _this2$_sdk$tokenMana = _this2._sdk.tokenManager.getTokensSync(),\n                        accessToken = _this2$_sdk$tokenMana.accessToken,\n                        idToken = _this2$_sdk$tokenMana.idToken,\n                        refreshToken = _this2$_sdk$tokenMana.refreshToken;\n\n                    var authState = {\n                      accessToken: accessToken,\n                      idToken: idToken,\n                      refreshToken: refreshToken,\n                      isAuthenticated: !!(accessToken && idToken)\n                    };\n                    var promise = transformAuthState ? _this2._transformQueue.push(transformAuthState, null, _this2._sdk, authState) : Promise.resolve(authState);\n                    promise.then(function (authState) {\n                      return emitAndResolve(authState);\n                    }).catch(function (error) {\n                      return emitAndResolve({\n                        accessToken: accessToken,\n                        idToken: idToken,\n                        refreshToken: refreshToken,\n                        isAuthenticated: false,\n                        error: error\n                      });\n                    });\n                  });\n                });\n                this._pending.updateAuthStatePromise = cancelablePromise;\n                return _context.abrupt(\"return\", finalPromise(cancelablePromise));\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateAuthState() {\n        return _updateAuthState.apply(this, arguments);\n      }\n\n      return updateAuthState;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(handler) {\n      this._sdk.emitter.on(EVENT_AUTH_STATE_CHANGE, handler);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(handler) {\n      this._sdk.emitter.off(EVENT_AUTH_STATE_CHANGE, handler);\n    }\n  }]);\n\n  return AuthStateManager;\n}();\n\nexport { AuthStateManager, INITIAL_AUTH_STATE };","map":{"version":3,"mappings":"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","names":["INITIAL_AUTH_STATE","DEFAULT_PENDING","updateAuthStatePromise","canceledTimes","EVENT_AUTH_STATE_CHANGE","MAX_PROMISE_CANCEL_TIMES","isSameAuthState","prevState","state","isAuthenticated","JSON","stringify","idToken","accessToken","error","AuthStateManager","sdk","emitter","AuthSdkError","_sdk","_pending","Object","_authState","_logOptions","_prevAuthState","_transformQueue","PromiseQueue","quiet","tokenManager","on","EVENT_ADDED","key","token","_setLogOptions","event","updateAuthState","EVENT_REMOVED","options","transformAuthState","devMode","log","status","getConsole","group","groupEnd","emitAuthStateChange","authState","emit","finalPromise","origPromise","then","curPromise","getAuthState","cancel","cancelablePromise","PCancelable","resolve","_","onCancel","shouldReject","emitAndResolve","isCanceled","getTokensSync","refreshToken","promise","push","Promise","catch","handler","off"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\AuthStateManager.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n \n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore \n// Do not use this type in code, so it won't be emitted in the declaration output\nimport PCancelable from 'p-cancelable';\nimport { AuthSdkError } from './errors';\nimport { AuthState, AuthStateLogOptions, EVENT_ADDED, EVENT_REMOVED } from './types';\nimport { OktaAuth } from '.';\nimport { getConsole } from './util';\nimport PromiseQueue from './PromiseQueue';\n\nexport const INITIAL_AUTH_STATE = null;\nconst DEFAULT_PENDING = {\n  updateAuthStatePromise: null,\n  canceledTimes: 0\n};\nconst EVENT_AUTH_STATE_CHANGE = 'authStateChange';\nconst MAX_PROMISE_CANCEL_TIMES = 10;\n\n// only compare first level of authState\nconst isSameAuthState = (prevState: AuthState | null, state: AuthState) => {\n  // initial state is null\n  if (!prevState) {\n    return false;\n  }\n\n  return prevState.isAuthenticated === state.isAuthenticated \n    && JSON.stringify(prevState.idToken) === JSON.stringify(state.idToken)\n    && JSON.stringify(prevState.accessToken) === JSON.stringify(state.accessToken)\n    && prevState.error === state.error;\n};\n\n\nexport class AuthStateManager {\n  _sdk: OktaAuth;\n  _pending: { \n    updateAuthStatePromise: any;\n    canceledTimes: number; \n  };\n  _authState: AuthState | null;\n  _prevAuthState: AuthState | null;\n  _logOptions: AuthStateLogOptions;\n  _transformQueue: PromiseQueue;\n\n  constructor(sdk: OktaAuth) {\n    if (!sdk.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before AuthStateManager');\n    }\n\n    this._sdk = sdk;\n    this._pending = { ...DEFAULT_PENDING };\n    this._authState = INITIAL_AUTH_STATE;\n    this._logOptions = {};\n    this._prevAuthState = null;\n    this._transformQueue = new PromiseQueue({\n      quiet: true\n    });\n\n    // Listen on tokenManager events to start updateState process\n    // \"added\" event is emitted in both add and renew process\n    // Only listen on \"added\" event to update auth state\n    sdk.tokenManager.on(EVENT_ADDED, (key, token) => {\n      this._setLogOptions({ event: EVENT_ADDED, key, token });\n      this.updateAuthState();\n    });\n    sdk.tokenManager.on(EVENT_REMOVED, (key, token) => {\n      this._setLogOptions({ event: EVENT_REMOVED, key, token });\n      this.updateAuthState();\n    });\n  }\n\n  _setLogOptions(options) {\n    this._logOptions = options;\n  }\n\n  getAuthState(): AuthState | null {\n    return this._authState;\n  }\n\n  getPreviousAuthState(): AuthState | null {\n    return this._prevAuthState;\n  }\n\n  async updateAuthState(): Promise<AuthState> {\n    const { transformAuthState, devMode } = this._sdk.options;\n\n    const log = (status) => {\n      const { event, key, token } = this._logOptions;\n      getConsole().group(`OKTA-AUTH-JS:updateAuthState: Event:${event} Status:${status}`);\n      getConsole().log(key, token);\n      getConsole().log('Current authState', this._authState);\n      getConsole().groupEnd();\n      \n      // clear log options after logging\n      this._logOptions = {};\n    };\n\n    const emitAuthStateChange = (authState) => {\n      if (isSameAuthState(this._authState, authState)) {\n        devMode && log('unchanged'); \n        return;\n      }\n      this._prevAuthState = this._authState;\n      this._authState = authState;\n      // emit new authState object\n      this._sdk.emitter.emit(EVENT_AUTH_STATE_CHANGE, { ...authState });\n      devMode && log('emitted');\n    };\n\n    const finalPromise = (origPromise) => {       \n      return this._pending.updateAuthStatePromise.then(() => {\n        const curPromise = this._pending.updateAuthStatePromise;\n        if (curPromise && curPromise !== origPromise) {\n          return finalPromise(curPromise);\n        }\n        return this.getAuthState();\n      });\n    };\n\n    if (this._pending.updateAuthStatePromise) {\n      if (this._pending.canceledTimes >= MAX_PROMISE_CANCEL_TIMES) {\n        // stop canceling then starting a new promise\n        // let existing promise finish to prevent running into loops\n        devMode && log('terminated');\n        return finalPromise(this._pending.updateAuthStatePromise);\n      } else {\n        this._pending.updateAuthStatePromise.cancel();\n      }\n    }\n\n    /* eslint-disable complexity */\n    const cancelablePromise = new PCancelable((resolve, _, onCancel) => {\n      onCancel.shouldReject = false;\n      onCancel(() => {\n        this._pending.updateAuthStatePromise = null;\n        this._pending.canceledTimes = this._pending.canceledTimes + 1;\n        devMode && log('canceled');\n      });\n\n      const emitAndResolve = (authState) => {\n        if (cancelablePromise.isCanceled) {\n          resolve();\n          return;\n        }\n        // emit event and resolve promise \n        emitAuthStateChange(authState);\n        resolve();\n\n        // clear pending states after resolve\n        this._pending = { ...DEFAULT_PENDING };\n      };\n\n      this._sdk.isAuthenticated()\n        .then(() => {\n          if (cancelablePromise.isCanceled) {\n            resolve();\n            return;\n          }\n\n          const { accessToken, idToken, refreshToken } = this._sdk.tokenManager.getTokensSync();\n          const authState = {\n            accessToken,\n            idToken,\n            refreshToken,\n            isAuthenticated: !!(accessToken && idToken)\n          };\n\n          // Enqueue transformAuthState so that it does not run concurrently\n          const promise: Promise<AuthState> = transformAuthState\n            ? this._transformQueue.push(transformAuthState, null, this._sdk, authState) as Promise<AuthState>\n            : Promise.resolve(authState);\n\n          promise\n            .then(authState => emitAndResolve(authState))\n            .catch(error => emitAndResolve({\n              accessToken, \n              idToken, \n              refreshToken,\n              isAuthenticated: false, \n              error\n            }));\n        });\n    });\n    /* eslint-enable complexity */\n    this._pending.updateAuthStatePromise = cancelablePromise;\n\n    return finalPromise(cancelablePromise);\n  }\n\n  subscribe(handler): void {\n    this._sdk.emitter.on(EVENT_AUTH_STATE_CHANGE, handler);\n  }\n\n  unsubscribe(handler?): void {\n    this._sdk.emitter.off(EVENT_AUTH_STATE_CHANGE, handler);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}