{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { warn } from '../util/console.js';\nimport { removeNils } from '../util/object.js';\nimport { createOAuthMeta } from '../oidc/util/oauthMeta.js';\nimport './types/api.js';\nimport '../myaccount/types.js';\n\nfunction createTransactionMeta(_x) {\n  return _createTransactionMeta.apply(this, arguments);\n}\n\nfunction _createTransactionMeta() {\n  _createTransactionMeta = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authClient) {\n    var options,\n        tokenParams,\n        pkceMeta,\n        _Object$assign,\n        _Object$assign$flow,\n        flow,\n        _Object$assign$withCr,\n        withCredentials,\n        _Object$assign$activa,\n        activationToken,\n        _Object$assign$recove,\n        recoveryToken,\n        _Object$assign$maxAge,\n        maxAge,\n        meta,\n        _args = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _context.next = 3;\n            return authClient.token.prepareTokenParams(options);\n\n          case 3:\n            tokenParams = _context.sent;\n            pkceMeta = createOAuthMeta(authClient, tokenParams);\n            _Object$assign = Object.assign(Object.assign({}, authClient.options), options), _Object$assign$flow = _Object$assign.flow, flow = _Object$assign$flow === void 0 ? 'default' : _Object$assign$flow, _Object$assign$withCr = _Object$assign.withCredentials, withCredentials = _Object$assign$withCr === void 0 ? true : _Object$assign$withCr, _Object$assign$activa = _Object$assign.activationToken, activationToken = _Object$assign$activa === void 0 ? undefined : _Object$assign$activa, _Object$assign$recove = _Object$assign.recoveryToken, recoveryToken = _Object$assign$recove === void 0 ? undefined : _Object$assign$recove, _Object$assign$maxAge = _Object$assign.maxAge, maxAge = _Object$assign$maxAge === void 0 ? undefined : _Object$assign$maxAge;\n            meta = Object.assign(Object.assign({}, pkceMeta), {\n              flow: flow,\n              withCredentials: withCredentials,\n              activationToken: activationToken,\n              recoveryToken: recoveryToken,\n              maxAge: maxAge\n            });\n            return _context.abrupt(\"return\", meta);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _createTransactionMeta.apply(this, arguments);\n}\n\nfunction hasSavedInteractionHandle(authClient, options) {\n  var savedMeta = getSavedTransactionMeta(authClient, options);\n\n  if (savedMeta === null || savedMeta === void 0 ? void 0 : savedMeta.interactionHandle) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSavedTransactionMeta(authClient, options) {\n  options = removeNils(options);\n  options = Object.assign(Object.assign({}, authClient.options), options);\n  var savedMeta;\n\n  try {\n    savedMeta = authClient.transactionManager.load(options);\n  } catch (e) {}\n\n  if (!savedMeta) {\n    return;\n  }\n\n  if (isTransactionMetaValid(savedMeta, options)) {\n    return savedMeta;\n  }\n\n  warn('Saved transaction meta does not match the current configuration. ' + 'This may indicate that two apps are sharing a storage key.');\n}\n\nfunction getTransactionMeta(_x2, _x3) {\n  return _getTransactionMeta.apply(this, arguments);\n}\n\nfunction _getTransactionMeta() {\n  _getTransactionMeta = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authClient, options) {\n    var validExistingMeta;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = removeNils(options);\n            options = Object.assign(Object.assign({}, authClient.options), options);\n            validExistingMeta = getSavedTransactionMeta(authClient, options);\n\n            if (!validExistingMeta) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", validExistingMeta);\n\n          case 5:\n            return _context2.abrupt(\"return\", createTransactionMeta(authClient, options));\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getTransactionMeta.apply(this, arguments);\n}\n\nfunction saveTransactionMeta(authClient, meta) {\n  authClient.transactionManager.save(meta, {\n    muteWarning: true\n  });\n}\n\nfunction clearTransactionMeta(authClient) {\n  authClient.transactionManager.clear();\n}\n\nfunction isTransactionMetaValid(meta) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var keys = ['issuer', 'clientId', 'redirectUri', 'state', 'codeChallenge', 'codeChallengeMethod', 'activationToken', 'recoveryToken'];\n\n  if (isTransactionMetaValidForOptions(meta, options, keys) === false) {\n    return false;\n  }\n\n  var flow = options.flow;\n\n  if (isTransactionMetaValidForFlow(meta, flow) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTransactionMetaValidForFlow(meta, flow) {\n  var shouldValidateFlow = flow && flow !== 'default' && flow !== 'proceed';\n\n  if (shouldValidateFlow) {\n    if (flow !== meta.flow) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTransactionMetaValidForOptions(meta, options, keys) {\n  var mismatch = keys.some(function (key) {\n    var value = options[key];\n\n    if (value && value !== meta[key]) {\n      return true;\n    }\n  });\n  return !mismatch;\n}\n\nexport { clearTransactionMeta, createTransactionMeta, getSavedTransactionMeta, getTransactionMeta, hasSavedInteractionHandle, isTransactionMetaValid, isTransactionMetaValidForFlow, isTransactionMetaValidForOptions, saveTransactionMeta };","map":{"version":3,"mappings":"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","names":["createTransactionMeta","authClient","options","token","prepareTokenParams","tokenParams","pkceMeta","createOAuthMeta","Object","flow","withCredentials","activationToken","undefined","recoveryToken","maxAge","meta","savedMeta","getSavedTransactionMeta","interactionHandle","removeNils","transactionManager","load","e","isTransactionMetaValid","warn","getTransactionMeta","validExistingMeta","save","muteWarning","clearTransactionMeta","clear","keys","isTransactionMetaValidForOptions","isTransactionMetaValidForFlow","shouldValidateFlow","mismatch","some","value","key"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\idx\\transactionMeta.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/*!\n * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { OktaAuthIdxInterface, IdxTransactionMeta, TransactionMetaOptions, PKCETransactionMeta } from '../types';\nimport { removeNils, warn } from '../util';\nimport { createOAuthMeta } from '../oidc';\n\n// Calculate new values\nexport async function createTransactionMeta(\n  authClient: OktaAuthIdxInterface,\n  options: TransactionMetaOptions = {}\n): Promise<IdxTransactionMeta> {\n  const tokenParams = await authClient.token.prepareTokenParams(options);\n  const pkceMeta = createOAuthMeta(authClient, tokenParams) as PKCETransactionMeta;\n  let {\n    flow = 'default',\n    withCredentials = true,\n    activationToken = undefined,\n    recoveryToken = undefined,\n    maxAge = undefined,\n  } = { ...authClient.options, ...options }; // local options override SDK options\n\n  const meta: IdxTransactionMeta = {\n    ...pkceMeta,\n    flow,\n    withCredentials,\n    activationToken,\n    recoveryToken,\n    maxAge\n  };\n  return meta;\n}\n\nexport function hasSavedInteractionHandle(authClient: OktaAuthIdxInterface, options?: TransactionMetaOptions): boolean {\n  const savedMeta = getSavedTransactionMeta(authClient, options);\n  if (savedMeta?.interactionHandle) {\n    return true;\n  }\n  return false;\n}\n\n// Returns the saved transaction meta, if it exists and is valid\nexport function getSavedTransactionMeta(\n  authClient: OktaAuthIdxInterface,\n  options?: TransactionMetaOptions\n): IdxTransactionMeta | undefined {\n  options = removeNils(options);\n  options = { ...authClient.options, ...options }; // local options override SDK options\n  let savedMeta;\n  try {\n    savedMeta = authClient.transactionManager.load(options) as IdxTransactionMeta;\n  } catch (e) {\n    // ignore errors here\n  }\n\n  if (!savedMeta) {\n    return;\n  }\n\n  if (isTransactionMetaValid(savedMeta, options)) {\n    return savedMeta;\n  }\n\n  // existing meta is not valid for this configuration\n  // this is common when changing configuration in local development environment\n  // in a production environment, this may indicate that two apps are sharing a storage key\n  warn('Saved transaction meta does not match the current configuration. ' + \n    'This may indicate that two apps are sharing a storage key.');\n\n}\n\nexport async function getTransactionMeta(\n  authClient: OktaAuthIdxInterface,\n  options?: TransactionMetaOptions\n): Promise<IdxTransactionMeta> {\n  options = removeNils(options);\n  options = { ...authClient.options, ...options }; // local options override SDK options\n  // Load existing transaction meta from storage\n  const validExistingMeta = getSavedTransactionMeta(authClient, options);\n  if (validExistingMeta) {\n    return validExistingMeta;\n  }\n  // No existing? Create new transaction meta.\n  return createTransactionMeta(authClient, options);\n}\n\nexport function saveTransactionMeta (authClient: OktaAuthIdxInterface, meta): void {\n  authClient.transactionManager.save(meta, { muteWarning: true });\n}\n\nexport function clearTransactionMeta (authClient: OktaAuthIdxInterface): void {\n  authClient.transactionManager.clear();\n}\n\nexport function isTransactionMetaValid (meta, options: TransactionMetaOptions  = {}): boolean {\n  // Validate against certain options. If these exist in options, they must match in meta\n  const keys = [\n    'issuer',\n    'clientId',\n    'redirectUri',\n    'state',\n    'codeChallenge',\n    'codeChallengeMethod',\n    'activationToken',\n    'recoveryToken'\n  ];\n  if (isTransactionMetaValidForOptions(meta, options, keys) === false) {\n    return false;\n  }\n\n  // Validate configured flow\n  const { flow } = options;\n  if (isTransactionMetaValidForFlow(meta, flow) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isTransactionMetaValidForFlow(meta, flow) {\n  // Specific flows should not share transaction data\n  const shouldValidateFlow = flow && flow !== 'default' && flow !== 'proceed';\n  if (shouldValidateFlow) {\n    if (flow !== meta.flow) {\n      // The flow has changed; abandon the old transaction\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransactionMetaValidForOptions(meta, options, keys) {\n  // returns false if values in meta do not match options\n  // if the option does not have a value for a specific key, it is ignored\n  const mismatch = keys.some(key => {\n    const value = options[key];\n    if (value && value !== meta[key]) {\n      return true;\n    }\n  });\n  return !mismatch;\n}\n"]},"metadata":{},"sourceType":"module"}