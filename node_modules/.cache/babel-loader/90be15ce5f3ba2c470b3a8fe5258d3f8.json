{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { getWellKnown, getKey } from './endpoints/well-known.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getOidcHash } from '../crypto/oidcHash.js';\nimport { verifyToken as verifyToken$1 } from '../crypto/verifyToken.js';\nimport { validateClaims } from './util/validateClaims.js';\nimport '../idx/types/api.js';\nimport '../myaccount/types.js';\nimport { decodeToken } from './decodeToken.js';\n\nfunction verifyToken(_x, _x2, _x3) {\n  return _verifyToken.apply(this, arguments);\n}\n\nfunction _verifyToken() {\n  _verifyToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sdk, token, validationParams) {\n    var jwt, configuredIssuer, _yield$getWellKnown, issuer, validationOptions, key, valid, hash;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!token || !token.idToken)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new AuthSdkError('Only idTokens may be verified');\n\n          case 2:\n            jwt = decodeToken(token.idToken);\n            configuredIssuer = (validationParams === null || validationParams === void 0 ? void 0 : validationParams.issuer) || sdk.options.issuer;\n            _context.next = 6;\n            return getWellKnown(sdk, configuredIssuer);\n\n          case 6:\n            _yield$getWellKnown = _context.sent;\n            issuer = _yield$getWellKnown.issuer;\n            validationOptions = Object.assign({\n              clientId: sdk.options.clientId,\n              ignoreSignature: sdk.options.ignoreSignature\n            }, validationParams, {\n              issuer: issuer\n            });\n            validateClaims(sdk, jwt.payload, validationOptions);\n\n            if (!(validationOptions.ignoreSignature == true || !sdk.features.isTokenVerifySupported())) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt(\"return\", token);\n\n          case 12:\n            _context.next = 14;\n            return getKey(sdk, token.issuer, jwt.header.kid);\n\n          case 14:\n            key = _context.sent;\n            _context.next = 17;\n            return verifyToken$1(token.idToken, key);\n\n          case 17:\n            valid = _context.sent;\n\n            if (valid) {\n              _context.next = 20;\n              break;\n            }\n\n            throw new AuthSdkError('The token signature is not valid');\n\n          case 20:\n            if (!(validationParams && validationParams.accessToken && token.claims.at_hash)) {\n              _context.next = 26;\n              break;\n            }\n\n            _context.next = 23;\n            return getOidcHash(validationParams.accessToken);\n\n          case 23:\n            hash = _context.sent;\n\n            if (!(hash !== token.claims.at_hash)) {\n              _context.next = 26;\n              break;\n            }\n\n            throw new AuthSdkError('Token hash verification failed');\n\n          case 26:\n            return _context.abrupt(\"return\", token);\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _verifyToken.apply(this, arguments);\n}\n\nexport { verifyToken };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;SAsBsBA,W;;;;;4EAAf,iBAA2BC,GAA3B,EAAuDC,KAAvD,EAAuEC,gBAAvE;IAAA;;IAAA;MAAA;QAAA;UAAA;YAAA,MACD,CAACD,KAAD,IAAU,CAACA,KAAK,CAACE,OADhB;cAAA;cAAA;YAAA;;YAAA,MAEG,IAAIC,YAAJ,CAAiB,+BAAjB,CAFH;;UAAA;YAMDC,GANC,GAMKC,WAAW,CAACL,KAAK,CAACE,OAAP,CANhB;YAUCI,gBAVD,GAUoB,iBAAgB,SAAhB,oBAAgB,KAAhB,kCAAgB,CAAEC,MAAlB,KAA4BR,GAAG,CAACS,OAAJ,CAAYD,MAV5D;YAAA;YAAA,OAWoBE,YAAY,CAACV,GAAD,EAAMO,gBAAN,CAXhC;;UAAA;YAAA;YAWGC,MAXH,uBAWGA,MAXH;YAaDG,iBAbC,GAasCC,MAAM,CAACC,MAAP,CAAc;cAEvDC,QAAQ,EAAEd,GAAG,CAACS,OAAJ,CAAYK,QAFiC;cAGvDC,eAAe,EAAEf,GAAG,CAACS,OAAJ,CAAYM;YAH0B,CAAd,EAIxCb,gBAJwC,EAItB;cAEnBM,MAAM,EAANA;YAFmB,CAJsB,CAbtC;YAuBLQ,cAAc,CAAChB,GAAD,EAAMK,GAAG,CAACY,OAAV,EAAmBN,iBAAnB,CAAd;;YAvBK,MA2BDA,iBAAiB,CAACI,eAAlB,IAAqC,IAArC,IAA6C,CAACf,GAAG,CAACkB,QAAJ,CAAaC,sBAAb,EA3B7C;cAAA;cAAA;YAAA;;YAAA,iCA4BIlB,KA5BJ;;UAAA;YAAA;YAAA,OAgCamB,MAAM,CAACpB,GAAD,EAAMC,KAAK,CAACO,MAAZ,EAAoBH,GAAG,CAACgB,MAAJ,CAAWC,GAA/B,CAhCnB;;UAAA;YAgCCC,GAhCD;YAAA;YAAA,OAiCeC,aAAqB,CAACvB,KAAK,CAACE,OAAP,EAAgBoB,GAAhB,CAjCpC;;UAAA;YAiCCE,KAjCD;;YAAA,IAkCAA,KAlCA;cAAA;cAAA;YAAA;;YAAA,MAmCG,IAAIrB,YAAJ,CAAiB,kCAAjB,CAnCH;;UAAA;YAAA,MAqCDF,gBAAgB,IAAIA,gBAAgB,CAACwB,WAArC,IAAoDzB,KAAK,CAAC0B,MAAN,CAAaC,OArChE;cAAA;cAAA;YAAA;;YAAA;YAAA,OAsCgBC,WAAqB,CAAC3B,gBAAgB,CAACwB,WAAlB,CAtCrC;;UAAA;YAsCGI,IAtCH;;YAAA,MAuCCA,IAAI,KAAK7B,KAAK,CAAC0B,MAAN,CAAaC,OAvCvB;cAAA;cAAA;YAAA;;YAAA,MAwCK,IAAIxB,YAAJ,CAAiB,gCAAjB,CAxCL;;UAAA;YAAA,iCA2CEH,KA3CF;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C","names":["verifyToken","sdk","token","validationParams","idToken","AuthSdkError","jwt","decodeToken","configuredIssuer","issuer","options","getWellKnown","validationOptions","Object","assign","clientId","ignoreSignature","validateClaims","payload","features","isTokenVerifySupported","getKey","header","kid","key","sdkCrypto.verifyToken","valid","accessToken","claims","at_hash","sdkCrypto.getOidcHash","hash"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\oidc\\verifyToken.ts"],"sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable complexity */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { getWellKnown, getKey } from './endpoints/well-known';\nimport { validateClaims } from './util';\nimport { AuthSdkError } from '../errors';\nimport { IDToken, OktaAuthOIDCInterface, TokenVerifyParams } from '../types';\nimport { decodeToken } from './decodeToken';\nimport * as sdkCrypto from '../crypto';\n\n// Verify the id token\nexport async function verifyToken(sdk: OktaAuthOIDCInterface, token: IDToken, validationParams: TokenVerifyParams): Promise<IDToken> {\n  if (!token || !token.idToken) {\n    throw new AuthSdkError('Only idTokens may be verified');\n  }\n\n  // Decode the Jwt object (may throw)\n  var jwt = decodeToken(token.idToken);\n\n  // The configured issuer may point to a frontend proxy.\n  // Get the \"real\" issuer from .well-known/openid-configuration\n  const configuredIssuer = validationParams?.issuer || sdk.options.issuer;\n  const { issuer } = await getWellKnown(sdk, configuredIssuer);\n\n  var validationOptions: TokenVerifyParams = Object.assign({\n    // base options, can be overridden by params\n    clientId: sdk.options.clientId,\n    ignoreSignature: sdk.options.ignoreSignature\n  }, validationParams, {\n    // final options, cannot be overridden\n    issuer\n  });\n\n  // Standard claim validation (may throw)\n  validateClaims(sdk, jwt.payload, validationOptions);\n\n  // If the browser doesn't support native crypto or we choose not\n  // to verify the signature, bail early\n  if (validationOptions.ignoreSignature == true || !sdk.features.isTokenVerifySupported()) {\n    return token;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const key = await getKey(sdk, token.issuer, jwt.header.kid!);\n  const valid = await sdkCrypto.verifyToken(token.idToken, key);\n  if (!valid) {\n    throw new AuthSdkError('The token signature is not valid');\n  }\n  if (validationParams && validationParams.accessToken && token.claims.at_hash) {\n    const hash = await sdkCrypto.getOidcHash(validationParams.accessToken);\n    if (hash !== token.claims.at_hash) {\n      throw new AuthSdkError('Token hash verification failed');\n    }\n  }\n  return token;\n}\n"]},"metadata":{},"sourceType":"module"}