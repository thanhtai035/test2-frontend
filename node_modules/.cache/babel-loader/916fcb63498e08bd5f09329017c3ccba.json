{"ast":null,"code":"import _slicedToArray from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { JSONPath } from 'jsonpath-plus';\nvar SKIP_FIELDS = Object.fromEntries(['remediation', 'context'].map(function (field) {\n  return [field, !!'skip this field'];\n}));\n\nvar parseNonRemediations = function parseNonRemediations(authClient, idxResponse) {\n  var toPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var actions = {};\n  var context = {};\n  Object.keys(idxResponse).filter(function (field) {\n    return !SKIP_FIELDS[field];\n  }).forEach(function (field) {\n    var fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n\n    if (!fieldIsObject) {\n      context[field] = idxResponse[field];\n      return;\n    }\n\n    if (idxResponse[field].rel) {\n      actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n      return;\n    }\n\n    var _a = idxResponse[field],\n        fieldValue = _a.value,\n        type = _a.type,\n        info = __rest(_a, [\"value\", \"type\"]);\n\n    context[field] = Object.assign({\n      type: type\n    }, info);\n\n    if (type !== 'object') {\n      context[field].value = fieldValue;\n      return;\n    }\n\n    context[field].value = {};\n    Object.entries(fieldValue).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          subField = _ref2[0],\n          value = _ref2[1];\n\n      if (value.rel) {\n        actions[\"\".concat(field, \"-\").concat(subField.name || subField)] = generateIdxAction(authClient, value, toPersist);\n      } else {\n        context[field].value[subField] = value;\n      }\n    });\n  });\n  return {\n    context: context,\n    actions: actions\n  };\n};\n\nvar expandRelatesTo = function expandRelatesTo(idxResponse, value) {\n  Object.keys(value).forEach(function (k) {\n    if (k === 'relatesTo') {\n      var query = Array.isArray(value[k]) ? value[k][0] : value[k];\n\n      if (typeof query === 'string') {\n        var result = JSONPath({\n          path: query,\n          json: idxResponse\n        })[0];\n\n        if (result) {\n          value[k] = result;\n          return;\n        }\n      }\n    }\n\n    if (Array.isArray(value[k])) {\n      value[k].forEach(function (innerValue) {\n        return expandRelatesTo(idxResponse, innerValue);\n      });\n    }\n  });\n};\n\nvar convertRemediationAction = function convertRemediationAction(authClient, remediation, toPersist) {\n  if (remediation.rel) {\n    var remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n    var actionFn = remediationActions[remediation.name];\n    return Object.assign(Object.assign({}, remediation), {\n      action: actionFn\n    });\n  }\n\n  return remediation;\n};\n\nvar parseIdxResponse = function parseIdxResponse(authClient, idxResponse) {\n  var toPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  var remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n  remediationData.forEach(function (remediation) {\n    return expandRelatesTo(idxResponse, remediation);\n  });\n  var remediations = remediationData.map(function (remediation) {\n    return convertRemediationAction(authClient, remediation, toPersist);\n  });\n\n  var _parseNonRemediations = parseNonRemediations(authClient, idxResponse, toPersist),\n      context = _parseNonRemediations.context,\n      actions = _parseNonRemediations.actions;\n\n  return {\n    remediations: remediations,\n    context: context,\n    actions: actions\n  };\n};\n\nexport { parseIdxResponse, parseNonRemediations };","map":{"version":3,"mappings":"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","names":["SKIP_FIELDS","Object","fromEntries","map","field","parseNonRemediations","authClient","idxResponse","toPersist","actions","context","keys","filter","forEach","fieldIsObject","rel","name","generateIdxAction","fieldValue","_a","value","type","info","entries","subField","expandRelatesTo","k","query","Array","isArray","result","JSONPath","path","json","innerValue","convertRemediationAction","remediation","remediationActions","generateRemediationFunctions","actionFn","action","parseIdxResponse","remediationData","remediations"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\idx\\idxState\\v1\\idxResponseParser.ts"],"sourcesContent":["/*!\n * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n/* eslint-disable max-len */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport { OktaAuthIdxInterface } from '../../../types';    // auth-js/types\nimport { generateRemediationFunctions } from './remediationParser';\nimport generateIdxAction from './generateIdxAction';\nimport { JSONPath } from 'jsonpath-plus';\n\nconst SKIP_FIELDS = Object.fromEntries([\n  'remediation', // remediations are put into proceed/neededToProceed\n  'context', // the API response of 'context' isn't externally useful.  We ignore it and put all non-action (contextual) info into idxState.context\n].map( (field) => [ field, !!'skip this field' ] ));\n\nexport const parseNonRemediations = function parseNonRemediations( authClient: OktaAuthIdxInterface, idxResponse, toPersist = {} ) {\n  const actions = {};\n  const context = {};\n\n  Object.keys(idxResponse)\n    .filter( field => !SKIP_FIELDS[field])\n    .forEach( field => {\n      const fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n\n      if ( !fieldIsObject ) {\n        // simple fields are contextual info\n        context[field] = idxResponse[field];\n        return;\n      }\n\n      if ( idxResponse[field].rel ) {\n        // top level actions\n        actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n        return;\n      }\n\n      const { value: fieldValue, type, ...info} = idxResponse[field];\n      context[field] = { type, ...info}; // add the non-action parts as context\n\n      if ( type !== 'object' ) {\n        // only object values hold actions\n        context[field].value = fieldValue;\n        return;\n      }\n\n      // We are an object field containing an object value\n      context[field].value = {};\n      Object.entries(fieldValue)\n        .forEach( ([subField, value]) => {\n          if (value.rel) { // is [field].value[subField] an action?\n            // add any \"action\" value subfields to actions\n            actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);\n          } else {\n            // add non-action value subfields to context\n            context[field].value[subField] = value;\n          }\n        });\n    });\n\n  return { context, actions };\n};\n\nconst expandRelatesTo = (idxResponse, value) => {\n  Object.keys(value).forEach(k => {\n    if (k === 'relatesTo') {\n      const query = Array.isArray(value[k]) ? value[k][0] : value[k];\n      if (typeof query === 'string') {\n        // eslint-disable-next-line new-cap\n        const result = JSONPath({ path: query, json: idxResponse })[0];\n        if (result) {\n          value[k] = result;\n          return;\n        }\n      }\n    }\n    if (Array.isArray(value[k])) {\n      value[k].forEach(innerValue => expandRelatesTo(idxResponse, innerValue));\n    }\n  });\n};\n\nconst convertRemediationAction = (authClient: OktaAuthIdxInterface, remediation, toPersist) => {\n  // Only remediation that has `rel` field (indicator for form submission) can have http action\n  if (remediation.rel) {\n    const remediationActions = generateRemediationFunctions( authClient, [remediation], toPersist );\n    const actionFn = remediationActions[remediation.name];\n    return {\n      ...remediation,\n      action: actionFn,\n    };\n  }\n  \n  return remediation;\n};\n\nexport const parseIdxResponse = function parseIdxResponse( authClient: OktaAuthIdxInterface, idxResponse, toPersist = {} ): {\n  remediations: IdxRemediation[];\n  context: IdxContext;\n  actions: IdxActions;\n} {\n  const remediationData = idxResponse.remediation?.value || [];\n\n  remediationData.forEach(\n    remediation => expandRelatesTo(idxResponse, remediation)\n  );\n\n  const remediations = remediationData.map(remediation => convertRemediationAction( authClient, remediation, toPersist ));\n\n  const { context, actions } = parseNonRemediations( authClient, idxResponse, toPersist );\n\n  return {\n    remediations,\n    context,\n    actions,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}