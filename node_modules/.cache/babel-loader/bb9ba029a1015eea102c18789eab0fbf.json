{"ast":null,"code":"import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE } from './util.js';\nimport { add as unloadAdd } from 'unload';\n\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this.hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n\n  this._aplQ = PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls\n\n  this._aplQC = 0; // things to clean up\n\n  this._unl = []; // _unloads\n\n  this._lstns = []; // _listeners\n\n  this._dpL = function () {}; // onduplicate listener\n\n\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this.hasLeader = false;\n      }\n\n      if (msg.action === 'tell') {\n        _this.hasLeader = true;\n      }\n    }\n  };\n\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n\n  this._lstns.push(hasLeaderListener);\n};\n\nLeaderElection.prototype = {\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n    /**\n     * Already applying more then once,\n     * -> wait for the apply queue to be finished.\n     */\n\n\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n    /**\n     * Add a new apply-run\n     */\n\n\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var recieved = [];\n\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          recieved.push(msg);\n\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2.hasLeader = true;\n          }\n        }\n      };\n\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other intances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n\n\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n\n      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      }) // send again in case another instance was just created\n      .then(function () {\n        return _sendMessage(_this2, 'apply');\n      }) // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n\n      return applyPromise;\n    };\n\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if (\n    /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n\n    return this._aLP;\n  },\n\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n\n  die: function die() {\n    var _this3 = this;\n\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n\n    this._lstns = [];\n\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n\n    this._unl = [];\n\n    if (this.isLeader) {\n      this.hasLeader = false;\n      this.isLeader = false;\n    }\n\n    this.isDead = true;\n    return _sendMessage(this, 'death');\n  }\n};\n/**\n * @param leaderElector {LeaderElector}\n */\n\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n\n  return new Promise(function (res) {\n    var resolved = false;\n\n    function finish() {\n      if (resolved) {\n        return;\n      }\n\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    } // try once now\n\n\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n\n    var tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n\n    tryOnFallBack(); // try when other leader dies\n\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\n/**\n * sends and internal message over the broadcast-channel\n */\n\n\nfunction _sendMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\n\nexport function beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector.hasLeader = true;\n  var unloadFn = unloadAdd(function () {\n    return leaderElector.die();\n  });\n\n  leaderElector._unl.push(unloadFn);\n\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell');\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\n       * another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\n       */\n      leaderElector._dpLC = true;\n\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n\n\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n\n    }\n  };\n\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n\n  leaderElector._lstns.push(isLeaderListener);\n\n  return _sendMessage(leaderElector, 'tell');\n}\n\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n\n  return options;\n}\n\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = new LeaderElection(channel, options);\n\n  channel._befC.push(function () {\n    return elector.die();\n  });\n\n  channel._leaderElector = elector;\n  return elector;\n}","map":{"version":3,"names":["sleep","randomToken","PROMISE_RESOLVED_VOID","PROMISE_RESOLVED_TRUE","add","unloadAdd","LeaderElection","broadcastChannel","options","_this","_options","isLeader","hasLeader","isDead","token","_aplQ","_aplQC","_unl","_lstns","_dpL","_dpLC","hasLeaderListener","msg","context","action","addEventListener","push","prototype","applyOnce","isFromFallbackInterval","_this2","applyRun","stopCriteria","stopCriteriaPromiseResolve","stopCriteriaPromise","Promise","res","recieved","handleMessage","waitForAnswerTime","responseTime","applyPromise","_sendMessage","then","race","reject","Error","removeEventListener","beLeader","awaitLeadership","_aLP","_awaitLeadershipOnce","onduplicate","fn","die","_this3","forEach","listener","uFn","remove","leaderElector","resolved","finish","whenDeathListener","tryOnFallBack","fallbackInterval","msgJson","postInternal","unloadFn","isLeaderListener","fillOptionsWithDefaults","channel","JSON","parse","stringify","method","averageResponseTime","createLeaderElection","_leaderElector","elector","_befC"],"sources":["C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2-s3760615/node_modules/broadcast-channel/dist/esbrowser/leader-election.js"],"sourcesContent":["import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE } from './util.js';\nimport { add as unloadAdd } from 'unload';\n\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this.hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n\n  this._aplQ = PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls\n\n  this._aplQC = 0; // things to clean up\n\n  this._unl = []; // _unloads\n\n  this._lstns = []; // _listeners\n\n  this._dpL = function () {}; // onduplicate listener\n\n\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this.hasLeader = false;\n      }\n\n      if (msg.action === 'tell') {\n        _this.hasLeader = true;\n      }\n    }\n  };\n\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n\n  this._lstns.push(hasLeaderListener);\n};\n\nLeaderElection.prototype = {\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n    /**\n     * Already applying more then once,\n     * -> wait for the apply queue to be finished.\n     */\n\n\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n    /**\n     * Add a new apply-run\n     */\n\n\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var recieved = [];\n\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          recieved.push(msg);\n\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2.hasLeader = true;\n          }\n        }\n      };\n\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other intances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n\n\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n\n      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      }) // send again in case another instance was just created\n      .then(function () {\n        return _sendMessage(_this2, 'apply');\n      }) // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n\n      return applyPromise;\n    };\n\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if (\n    /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n\n    return this._aLP;\n  },\n\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n\n  die: function die() {\n    var _this3 = this;\n\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n\n    this._lstns = [];\n\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n\n    this._unl = [];\n\n    if (this.isLeader) {\n      this.hasLeader = false;\n      this.isLeader = false;\n    }\n\n    this.isDead = true;\n    return _sendMessage(this, 'death');\n  }\n};\n/**\n * @param leaderElector {LeaderElector}\n */\n\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n\n  return new Promise(function (res) {\n    var resolved = false;\n\n    function finish() {\n      if (resolved) {\n        return;\n      }\n\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    } // try once now\n\n\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n\n    var tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n\n    tryOnFallBack(); // try when other leader dies\n\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\n/**\n * sends and internal message over the broadcast-channel\n */\n\n\nfunction _sendMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\n\nexport function beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector.hasLeader = true;\n  var unloadFn = unloadAdd(function () {\n    return leaderElector.die();\n  });\n\n  leaderElector._unl.push(unloadFn);\n\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell');\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\n       * another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\n       */\n      leaderElector._dpLC = true;\n\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n\n\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n\n    }\n  };\n\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n\n  leaderElector._lstns.push(isLeaderListener);\n\n  return _sendMessage(leaderElector, 'tell');\n}\n\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n\n  return options;\n}\n\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = new LeaderElection(channel, options);\n\n  channel._befC.push(function () {\n    return elector.die();\n  });\n\n  channel._leaderElector = elector;\n  return elector;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}