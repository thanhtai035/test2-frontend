{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nfunction unwrapFormValue(remediation) {\n  if (Array.isArray(remediation)) {\n    return remediation.map(item => {\n      if (typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean') {\n        return item;\n      }\n\n      return unwrapFormValue(item);\n    });\n  }\n\n  const res = {};\n\n  for (const [key, value] of Object.entries(remediation)) {\n    if (value === null || typeof value === 'undefined') {\n      continue;\n    }\n\n    if (typeof value === 'object') {\n      const formKeys = Object.keys(value);\n\n      if (['value', 'form'].includes(key) && formKeys.length === 1 && ['value', 'form'].includes(formKeys[0])) {\n        const unwrappedForm = unwrapFormValue(value);\n        Object.entries(unwrappedForm).forEach(_ref => {\n          let [key, value] = _ref;\n          res[key] = value;\n        });\n      } else {\n        res[key] = unwrapFormValue(value);\n      }\n    } else {\n      res[key] = value;\n    }\n  }\n\n  return res;\n}\n\nexport { unwrapFormValue };","map":{"version":3,"mappings":";;;;;;;;;;;AAIM,SAAUA,eAAV,CAA0BC,WAA1B,EAAqC;EACzC,IAAIC,KAAK,CAACC,OAAN,CAAcF,WAAd,CAAJ,EAAgC;IAC9B,OAAOA,WAAW,CACfG,GADI,CACAC,IAAI,IAAG;MACV,IAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,QAA5C,IAAwD,OAAOA,IAAP,KAAgB,SAA5E,EAAuF;QACrF,OAAOA,IAAP;MACD;;MACD,OAAOL,eAAe,CAACK,IAAD,CAAtB;IACD,CANI,CAAP;EAOD;;EAED,MAAMC,GAAG,GAAG,EAAZ;;EACA,KAAK,MAAM,CAACC,GAAD,EAAMC,KAAN,CAAX,IAA2BC,MAAM,CAACC,OAAP,CAAeT,WAAf,CAA3B,EAAwD;IACtD,IAAIO,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,WAAvC,EAAoD;MAClD;IACD;;IAED,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC7B,MAAMG,QAAQ,GAAGF,MAAM,CAACG,IAAP,CAAYJ,KAAZ,CAAjB;;MAGA,IAAI,CAAC,OAAD,EAAU,MAAV,EAAkBK,QAAlB,CAA2BN,GAA3B,KACCI,QAAQ,CAACG,MAAT,KAAoB,CADrB,IAEC,CAAC,OAAD,EAAU,MAAV,EAAkBD,QAAlB,CAA2BF,QAAQ,CAAC,CAAD,CAAnC,CAFL,EAGE;QAEA,MAAMI,aAAa,GAAGf,eAAe,CAACQ,KAAD,CAArC;QACAC,MAAM,CAACC,OAAP,CAAeK,aAAf,EAA8BC,OAA9B,CAAsC,QAAiB;UAAA,IAAhB,CAACT,GAAD,EAAMC,KAAN,CAAgB;UACrDF,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;QACD,CAFD;MAGD,CATD,MASO;QAELF,GAAG,CAACC,GAAD,CAAH,GAAWP,eAAe,CAACQ,KAAD,CAA1B;MACD;IACF,CAjBD,MAiBO;MAELF,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;IACD;EACF;;EAED,OAAOF,GAAP;AACF","names":["unwrapFormValue","remediation","Array","isArray","map","item","res","key","value","Object","entries","formKeys","keys","includes","length","unwrappedForm","forEach"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\jobs-ui\\node_modules\\@okta\\lib\\idx\\remediators\\GenericRemediator\\util.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { AuthSdkError } from '../../../errors';\nimport { Input } from '../../types';\n\nexport function unwrapFormValue(remediation): Input { \n  if (Array.isArray(remediation)) {\n    return remediation\n      .map(item => {\n        if (typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean') {\n          return item;\n        }\n        return unwrapFormValue(item);\n      }) as any;\n  }\n\n  const res = {};\n  for (const [key, value] of Object.entries(remediation)) {\n    if (value === null || typeof value === 'undefined') {\n      continue;\n    }\n\n    if (typeof value === 'object') {\n      const formKeys = Object.keys(value as object);\n      // detect patterns like:\n      // value -> form -> value | form -> value\n      if (['value', 'form'].includes(key) \n        && formKeys.length === 1 \n        && ['value', 'form'].includes(formKeys[0])\n      ) {\n        // unwrap nested form\n        const unwrappedForm = unwrapFormValue(value);\n        Object.entries(unwrappedForm).forEach(([key, value]) => {\n          res[key] = value;\n        });\n      } else {\n        // dfs\n        res[key] = unwrapFormValue(value);\n      }\n    } else {\n      // handle primitive value\n      res[key] = value;\n    }\n  }\n\n  return res as Input;\n}\n\n// only check if value is required for now\n// TODO: support SDK layer type based input validation\nexport function hasValidInputValue(input, values) {\n  const fn = (input, values, requiredTracker) => {\n    const { name, value, type, options, required } = input;\n    const isRequired = required || requiredTracker;\n\n    // handle nested value - all required fields should be avaiable in values \n    if (Array.isArray(value)) {\n      return value.reduce((acc, item) => {\n        return acc && fn(item, values[name], isRequired); // recursive call\n      }, true);\n    }\n\n    // handle options field\n    // 1. object type options - check if each object field is required and value can be found from the selectedOption\n    // 2. primitive options - required field is avaiable from top level\n    // 3. unknown format - pass to backend for validation\n    if (options) {\n      // object type options\n      if (type === 'object') {\n        const selectedOption = values[name];\n        if (!selectedOption) {\n          return false;\n        }\n        if (!selectedOption.id) {\n          // unknown option format, pass to backend for validation\n          return true;\n        }\n        const optionSchema = options.find((option) => {\n          const idSchema = option.value.find(({ name }) => name === 'id' );\n          return idSchema.value === selectedOption.id;\n        });\n        if (!optionSchema) {\n          return false;\n        }\n        return optionSchema.value\n          .filter(({ required }) => !!required)\n          .reduce((acc, { name }) => {\n            return acc && !!selectedOption[name];\n          }, true);\n      }\n\n      // primitive options, not required - always valid\n      if (required === false) {\n        return true;\n      }\n\n      // primitive options, required - check if value is available\n      if (required === true) {\n        return !!values[name];\n      }\n\n      // unknown options, throw\n      throw new AuthSdkError(`Unknown options type, ${JSON.stringify(input)}`);\n    }\n\n    // base case\n    if (!isRequired) {\n      return true;\n    }\n      \n    return !!(values && values[name]);\n  };\n\n  return fn(input, values, false);\n}\n"]},"metadata":{},"sourceType":"module"}