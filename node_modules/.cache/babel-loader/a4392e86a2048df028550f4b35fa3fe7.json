{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { interact } from './interact.js';\nimport { introspect } from './introspect.js';\nimport { remediate } from './remediate.js';\nimport { IdxStatus } from './types/api.js';\nimport './remediators/EnrollAuthenticator.js';\nimport './remediators/EnrollPoll.js';\nimport './remediators/SelectEnrollmentChannel.js';\nimport './remediators/EnrollmentChannelData.js';\nimport './remediators/ChallengeAuthenticator.js';\nimport './remediators/ChallengePoll.js';\nimport './remediators/ResetAuthenticator.js';\nimport './remediators/EnrollProfile.js';\nimport './remediators/Identify.js';\nimport './remediators/ReEnrollAuthenticator.js';\nimport './remediators/RedirectIdp.js';\nimport './remediators/SelectAuthenticatorAuthenticate.js';\nimport './remediators/SelectAuthenticatorEnroll.js';\nimport './remediators/SelectAuthenticatorUnlockAccount.js';\nimport './remediators/SelectEnrollProfile.js';\nimport './remediators/AuthenticatorVerificationData.js';\nimport './remediators/AuthenticatorEnrollmentData.js';\nimport './remediators/Skip.js';\nimport { getFlowSpecification } from './flow/FlowSpecification.js';\nimport '../myaccount/types.js';\nimport { isIdxResponse } from './types/idx-js.js';\nimport { saveTransactionMeta, getSavedTransactionMeta } from './transactionMeta.js';\nimport { getEnabledFeatures, getAvailableSteps, getMessagesFromResponse, isTerminalResponse } from './util.js';\n\nfunction initializeValues(options) {\n  const knownOptions = ['flow', 'remediators', 'actions', 'withCredentials', 'step', 'useGenericRemediator', 'exchangeCodeForTokens', 'shouldProceedWithEmailAuthenticator'];\n  const values = Object.assign({}, options);\n  knownOptions.forEach(option => {\n    delete values[option];\n  });\n  return values;\n}\n\nfunction initializeData(authClient, data) {\n  let {\n    options\n  } = data;\n  options = Object.assign(Object.assign({}, authClient.options.idx), options);\n  let {\n    flow,\n    withCredentials,\n    remediators,\n    actions\n  } = options;\n  const status = IdxStatus.PENDING;\n  flow = flow || authClient.idx.getFlow() || 'default';\n\n  if (flow) {\n    authClient.idx.setFlow(flow);\n    const flowSpec = getFlowSpecification(authClient, flow);\n    withCredentials = typeof withCredentials !== 'undefined' ? withCredentials : flowSpec.withCredentials;\n    remediators = remediators || flowSpec.remediators;\n    actions = actions || flowSpec.actions;\n  }\n\n  return Object.assign(Object.assign({}, data), {\n    options: Object.assign(Object.assign({}, options), {\n      flow,\n      withCredentials,\n      remediators,\n      actions\n    }),\n    status\n  });\n}\n\nasync function getDataFromIntrospect(authClient, data) {\n  const {\n    options\n  } = data;\n  const {\n    stateHandle,\n    withCredentials,\n    version,\n    state,\n    scopes,\n    recoveryToken,\n    activationToken,\n    maxAge\n  } = options;\n  let idxResponse;\n  let meta = getSavedTransactionMeta(authClient, {\n    state,\n    recoveryToken,\n    activationToken\n  });\n\n  if (stateHandle) {\n    idxResponse = await introspect(authClient, {\n      withCredentials,\n      version,\n      stateHandle\n    });\n  } else {\n    let interactionHandle = meta === null || meta === void 0 ? void 0 : meta.interactionHandle;\n\n    if (!interactionHandle) {\n      authClient.transactionManager.clear();\n      const interactResponse = await interact(authClient, {\n        withCredentials,\n        state,\n        scopes,\n        activationToken,\n        recoveryToken,\n        maxAge\n      });\n      interactionHandle = interactResponse.interactionHandle;\n      meta = interactResponse.meta;\n    }\n\n    idxResponse = await introspect(authClient, {\n      withCredentials,\n      version,\n      interactionHandle\n    });\n  }\n\n  return Object.assign(Object.assign({}, data), {\n    idxResponse,\n    meta\n  });\n}\n\nasync function getDataFromRemediate(authClient, data) {\n  let {\n    idxResponse,\n    options,\n    values\n  } = data;\n  const {\n    autoRemediate,\n    remediators,\n    actions,\n    flow,\n    step,\n    shouldProceedWithEmailAuthenticator,\n    useGenericRemediator\n  } = options;\n  const shouldRemediate = autoRemediate !== false && (remediators || actions || step);\n\n  if (!shouldRemediate) {\n    return data;\n  }\n\n  values = Object.assign(Object.assign({}, values), {\n    stateHandle: idxResponse.rawIdxState.stateHandle\n  });\n  const {\n    idxResponse: idxResponseFromRemediation,\n    nextStep,\n    canceled\n  } = await remediate(authClient, idxResponse, values, {\n    remediators,\n    actions,\n    flow,\n    step,\n    shouldProceedWithEmailAuthenticator,\n    useGenericRemediator\n  });\n  idxResponse = idxResponseFromRemediation;\n  return Object.assign(Object.assign({}, data), {\n    idxResponse,\n    nextStep,\n    canceled\n  });\n}\n\nasync function getTokens(authClient, data) {\n  let {\n    meta,\n    idxResponse\n  } = data;\n  const {\n    interactionCode\n  } = idxResponse;\n  const {\n    clientId,\n    codeVerifier,\n    ignoreSignature,\n    redirectUri,\n    urls,\n    scopes\n  } = meta;\n  const tokenResponse = await authClient.token.exchangeCodeForTokens({\n    interactionCode,\n    clientId,\n    codeVerifier,\n    ignoreSignature,\n    redirectUri,\n    scopes\n  }, urls);\n  return tokenResponse.tokens;\n}\n\nasync function finalizeData(authClient, data) {\n  let {\n    options,\n    idxResponse,\n    canceled,\n    status\n  } = data;\n  const {\n    exchangeCodeForTokens\n  } = options;\n  let shouldSaveResponse = false;\n  let shouldClearTransaction = false;\n  let clearSharedStorage = true;\n  let interactionCode;\n  let tokens;\n  let enabledFeatures;\n  let availableSteps;\n  let messages;\n  let terminal;\n\n  if (idxResponse) {\n    shouldSaveResponse = !!(idxResponse.requestDidSucceed || idxResponse.stepUp);\n    enabledFeatures = getEnabledFeatures(idxResponse);\n    availableSteps = getAvailableSteps(authClient, idxResponse, options.useGenericRemediator);\n    messages = getMessagesFromResponse(idxResponse, options);\n    terminal = isTerminalResponse(idxResponse);\n  }\n\n  if (terminal) {\n    status = IdxStatus.TERMINAL;\n    const hasActions = Object.keys(idxResponse.actions).length > 0;\n    const hasErrors = !!messages.find(msg => msg.class === 'ERROR');\n    const isTerminalSuccess = !hasActions && !hasErrors && idxResponse.requestDidSucceed === true;\n\n    if (isTerminalSuccess) {\n      shouldClearTransaction = true;\n    } else {\n      shouldSaveResponse = shouldSaveResponse && hasActions;\n    }\n\n    clearSharedStorage = false;\n  } else if (canceled) {\n    status = IdxStatus.CANCELED;\n    shouldClearTransaction = true;\n  } else if (idxResponse === null || idxResponse === void 0 ? void 0 : idxResponse.interactionCode) {\n    interactionCode = idxResponse.interactionCode;\n\n    if (exchangeCodeForTokens === false) {\n      status = IdxStatus.SUCCESS;\n      shouldClearTransaction = false;\n    } else {\n      tokens = await getTokens(authClient, data);\n      status = IdxStatus.SUCCESS;\n      shouldClearTransaction = true;\n    }\n  }\n\n  return Object.assign(Object.assign({}, data), {\n    status,\n    interactionCode,\n    tokens,\n    shouldSaveResponse,\n    shouldClearTransaction,\n    clearSharedStorage,\n    enabledFeatures,\n    availableSteps,\n    messages,\n    terminal\n  });\n}\n\nfunction handleError(err, data) {\n  let {\n    error,\n    status,\n    shouldClearTransaction\n  } = data;\n\n  if (isIdxResponse(err)) {\n    error = err;\n    status = IdxStatus.FAILURE;\n    shouldClearTransaction = true;\n  } else {\n    throw err;\n  }\n\n  return Object.assign(Object.assign({}, data), {\n    error,\n    status,\n    shouldClearTransaction\n  });\n}\n\nasync function run(authClient) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  let data = {\n    options,\n    values: initializeValues(options)\n  };\n  data = initializeData(authClient, data);\n\n  try {\n    data = await getDataFromIntrospect(authClient, data);\n    data = await getDataFromRemediate(authClient, data);\n  } catch (err) {\n    data = handleError(err, data);\n  }\n\n  data = await finalizeData(authClient, data);\n  const {\n    idxResponse,\n    meta,\n    shouldSaveResponse,\n    shouldClearTransaction,\n    clearSharedStorage,\n    status,\n    enabledFeatures,\n    availableSteps,\n    tokens,\n    nextStep,\n    messages,\n    error,\n    interactionCode\n  } = data;\n\n  if (shouldClearTransaction) {\n    authClient.transactionManager.clear({\n      clearSharedStorage\n    });\n  } else {\n    saveTransactionMeta(authClient, Object.assign({}, meta));\n\n    if (shouldSaveResponse) {\n      const {\n        rawIdxState: rawIdxResponse,\n        requestDidSucceed\n      } = idxResponse;\n      authClient.transactionManager.saveIdxResponse({\n        rawIdxResponse,\n        requestDidSucceed,\n        stateHandle: (_a = idxResponse.context) === null || _a === void 0 ? void 0 : _a.stateHandle,\n        interactionHandle: meta === null || meta === void 0 ? void 0 : meta.interactionHandle\n      });\n    }\n  }\n\n  const {\n    actions,\n    context,\n    neededToProceed,\n    proceed,\n    rawIdxState,\n    requestDidSucceed,\n    stepUp\n  } = idxResponse || {};\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    status: status\n  }, meta && {\n    meta\n  }), enabledFeatures && {\n    enabledFeatures\n  }), availableSteps && {\n    availableSteps\n  }), tokens && {\n    tokens\n  }), nextStep && {\n    nextStep\n  }), messages && messages.length && {\n    messages\n  }), error && {\n    error\n  }), stepUp && {\n    stepUp\n  }), {\n    interactionCode,\n    actions: actions,\n    context: context,\n    neededToProceed: neededToProceed,\n    proceed: proceed,\n    rawIdxState: rawIdxState,\n    requestDidSucceed\n  });\n}\n\nexport { run };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA,SAASA,gBAAT,CAA0BC,OAA1B,EAA6C;EAE3C,MAAMC,YAAY,GAAG,CACnB,MADmB,EAEnB,aAFmB,EAGnB,SAHmB,EAInB,iBAJmB,EAKnB,MALmB,EAMnB,sBANmB,EAOnB,uBAPmB,EAQnB,qCARmB,CAArB;EAUA,MAAMC,MAAM,qBAAQF,OAAR,CAAZ;EACAC,YAAY,CAACE,OAAb,CAAqBC,MAAM,IAAG;IAC5B,OAAOF,MAAM,CAACE,MAAD,CAAb;EACD,CAFD;EAGA,OAAOF,MAAP;AACD;;AAED,SAASG,cAAT,CAAwBC,UAAxB,EAAoCC,IAApC,EAAiD;EAC/C,IAAI;IAAEP;EAAF,IAAcO,IAAlB;EACAP,OAAO,mCACFM,UAAU,CAACN,OAAX,CAAmBQ,GADjB,GAEFR,OAFE,CAAP;EAIA,IAAI;IACFS,IADE;IAEFC,eAFE;IAGFC,WAHE;IAIFC;EAJE,IAKAZ,OALJ;EAOA,MAAMa,MAAM,GAAGC,SAAS,CAACC,OAAzB;EAGAN,IAAI,GAAGA,IAAI,IAAIH,UAAU,CAACE,GAAX,CAAeQ,OAAf,EAAR,IAAoC,SAA3C;;EACA,IAAIP,IAAJ,EAAU;IACRH,UAAU,CAACE,GAAX,CAAeS,OAAf,CAAuBR,IAAvB;IACA,MAAMS,QAAQ,GAAGC,oBAAoB,CAACb,UAAD,EAAaG,IAAb,CAArC;IAEAC,eAAe,GAAI,OAAOA,eAAP,KAA2B,WAA5B,GAA2CA,eAA3C,GAA6DQ,QAAQ,CAACR,eAAxF;IACAC,WAAW,GAAGA,WAAW,IAAIO,QAAQ,CAACP,WAAtC;IACAC,OAAO,GAAGA,OAAO,IAAIM,QAAQ,CAACN,OAA9B;EACD;;EAED,uCACKL,IADL,GAEE;IAAAP,OAAO,EACFoB,0CAAO;MACVX,IADU;MAEVC,eAFU;MAGVC,WAHU;MAIVC;IAJU,CAAP,CADL;IAOAC;EAPA,CAFF;AAWD;;AAED,eAAeQ,qBAAf,CAAqCf,UAArC,EAAiDC,IAAjD,EAA8D;EAC5D,MAAM;IAAEP;EAAF,IAAcO,IAApB;EACA,MAAM;IACJe,WADI;IAEJZ,eAFI;IAGJa,OAHI;IAIJC,KAJI;IAKJC,MALI;IAMJC,aANI;IAOJC,eAPI;IAQJC;EARI,IASF5B,OATJ;EAWA,IAAI6B,WAAJ;EACA,IAAIC,IAAI,GAAGC,uBAAuB,CAACzB,UAAD,EAAa;IAAEkB,KAAF;IAASE,aAAT;IAAwBC;EAAxB,CAAb,CAAlC;;EAEA,IAAIL,WAAJ,EAAiB;IACfO,WAAW,GAAG,MAAMG,UAAU,CAAC1B,UAAD,EAAa;MAAEI,eAAF;MAAmBa,OAAnB;MAA4BD;IAA5B,CAAb,CAA9B;EACD,CAFD,MAEO;IACL,IAAIW,iBAAiB,GAAGH,IAAI,KAAJ,YAAI,KAAJ,sBAAI,CAAEG,iBAA9B;;IACA,IAAI,CAACA,iBAAL,EAAwB;MAEtB3B,UAAU,CAAC4B,kBAAX,CAA8BC,KAA9B;MACA,MAAMC,gBAAgB,GAAG,MAAMC,QAAQ,CAAC/B,UAAD,EAAa;QAClDI,eADkD;QAElDc,KAFkD;QAGlDC,MAHkD;QAIlDE,eAJkD;QAKlDD,aALkD;QAMlDE;MANkD,CAAb,CAAvC;MAQAK,iBAAiB,GAAGG,gBAAgB,CAACH,iBAArC;MACAH,IAAI,GAAGM,gBAAgB,CAACN,IAAxB;IACD;;IAGDD,WAAW,GAAG,MAAMG,UAAU,CAAC1B,UAAD,EAAa;MAAEI,eAAF;MAAmBa,OAAnB;MAA4BU;IAA5B,CAAb,CAA9B;EACD;;EACD,uCAAY1B,IAAZ,GAAgB;IAAEsB,WAAF;IAAeC;EAAf,CAAhB;AACD;;AAED,eAAeQ,oBAAf,CAAoChC,UAApC,EAAgDC,IAAhD,EAA6D;EAC3D,IAAI;IACFsB,WADE;IAEF7B,OAFE;IAGFE;EAHE,IAIAK,IAJJ;EAMA,MAAM;IACJgC,aADI;IAEJ5B,WAFI;IAGJC,OAHI;IAIJH,IAJI;IAKJ+B,IALI;IAMJC,mCANI;IAOJC;EAPI,IAQF1C,OARJ;EAUA,MAAM2C,eAAe,GAAIJ,aAAa,KAAK,KAAlB,KAA4B5B,WAAW,IAAIC,OAAf,IAA0B4B,IAAtD,CAAzB;;EACA,IAAI,CAACG,eAAL,EAAsB;IACpB,OAAOpC,IAAP;EACD;;EAEDL,MAAM,mCACDA,MADC,GACK;IACToB,WAAW,EAAEO,WAAY,CAACe,WAAb,CAAyBtB;EAD7B,CADL,CAAN;EAMA,MAAM;IACJO,WAAW,EAAEgB,0BADT;IAEJC,QAFI;IAGJC;EAHI,IAIF,MAAMC,SAAS,CACjB1C,UADiB,EAEjBuB,WAFiB,EAGjB3B,MAHiB,EAIjB;IACES,WADF;IAEEC,OAFF;IAGEH,IAHF;IAIE+B,IAJF;IAKEC,mCALF;IAMEC;EANF,CAJiB,CAJnB;EAiBAb,WAAW,GAAGgB,0BAAd;EAEA,uCAAYtC,IAAZ,GAAkB;IAAAsB;IAAaiB,QAAb;IAAuBC;EAAvB,CAAlB;AACD;;AAED,eAAeE,SAAf,CAAyB3C,UAAzB,EAAqCC,IAArC,EAAkD;EAChD,IAAI;IAAEuB,IAAF;IAAQD;EAAR,IAAwBtB,IAA5B;EACA,MAAM;IAAE2C;EAAF,IAAsBrB,WAA5B;EACA,MAAM;IACJsB,QADI;IAEJC,YAFI;IAGJC,eAHI;IAIJC,WAJI;IAKJC,IALI;IAMJ9B;EANI,IAOFK,IAPJ;EAQA,MAAM0B,aAAa,GAAG,MAAMlD,UAAU,CAACmD,KAAX,CAAiBC,qBAAjB,CAAuC;IACjER,eADiE;IAEjEC,QAFiE;IAGjEC,YAHiE;IAIjEC,eAJiE;IAKjEC,WALiE;IAMjE7B;EANiE,CAAvC,EAOzB8B,IAPyB,CAA5B;EAQA,OAAOC,aAAa,CAACG,MAArB;AACD;;AAED,eAAeC,YAAf,CAA4BtD,UAA5B,EAAwCC,IAAxC,EAAqD;EACnD,IAAI;IACFP,OADE;IAEF6B,WAFE;IAGFkB,QAHE;IAIFlC;EAJE,IAKAN,IALJ;EAMA,MAAM;IAAEmD;EAAF,IAA4B1D,OAAlC;EACA,IAAI6D,kBAAkB,GAAG,KAAzB;EACA,IAAIC,sBAAsB,GAAG,KAA7B;EACA,IAAIC,kBAAkB,GAAG,IAAzB;EACA,IAAIb,eAAJ;EACA,IAAIS,MAAJ;EACA,IAAIK,eAAJ;EACA,IAAIC,cAAJ;EACA,IAAIC,QAAJ;EACA,IAAIC,QAAJ;;EAEA,IAAItC,WAAJ,EAAiB;IACfgC,kBAAkB,GAAG,CAAC,EAAEhC,WAAW,CAACuC,iBAAZ,IAAiCvC,WAAW,CAACwC,MAA/C,CAAtB;IACAL,eAAe,GAAGM,kBAAkB,CAACzC,WAAD,CAApC;IACAoC,cAAc,GAAGM,iBAAiB,CAACjE,UAAD,EAAauB,WAAb,EAA0B7B,OAAO,CAAC0C,oBAAlC,CAAlC;IACAwB,QAAQ,GAAGM,uBAAuB,CAAC3C,WAAD,EAAc7B,OAAd,CAAlC;IACAmE,QAAQ,GAAGM,kBAAkB,CAAC5C,WAAD,CAA7B;EACD;;EAED,IAAIsC,QAAJ,EAAc;IACZtD,MAAM,GAAGC,SAAS,CAAC4D,QAAnB;IAMA,MAAMC,UAAU,GAAGvD,MAAM,CAACwD,IAAP,CAAY/C,WAAY,CAACjB,OAAzB,EAAkCiE,MAAlC,GAA2C,CAA9D;IACA,MAAMC,SAAS,GAAG,CAAC,CAACZ,QAAQ,CAACa,IAAT,CAAcC,GAAG,IAAIA,GAAG,CAACC,KAAJ,KAAc,OAAnC,CAApB;IACA,MAAMC,iBAAiB,GAAG,CAACP,UAAD,IAAe,CAACG,SAAhB,IAA6BjD,WAAY,CAACuC,iBAAb,KAAmC,IAA1F;;IACA,IAAIc,iBAAJ,EAAuB;MACrBpB,sBAAsB,GAAG,IAAzB;IACD,CAFD,MAEO;MAELD,kBAAkB,GAAGA,kBAAkB,IAAIc,UAA3C;IACD;;IAEDZ,kBAAkB,GAAG,KAArB;EACD,CAlBD,MAkBO,IAAIhB,QAAJ,EAAc;IACnBlC,MAAM,GAAGC,SAAS,CAACqE,QAAnB;IACArB,sBAAsB,GAAG,IAAzB;EACD,CAHM,MAGA,IAAIjC,WAAW,KAAX,mBAAW,WAAX,GAAW,MAAX,cAAW,CAAEqB,eAAjB,EAAkC;IACvCA,eAAe,GAAGrB,WAAW,CAACqB,eAA9B;;IACA,IAAIQ,qBAAqB,KAAK,KAA9B,EAAqC;MACnC7C,MAAM,GAAGC,SAAS,CAACsE,OAAnB;MACAtB,sBAAsB,GAAG,KAAzB;IACD,CAHD,MAGO;MACLH,MAAM,GAAG,MAAMV,SAAS,CAAC3C,UAAD,EAAaC,IAAb,CAAxB;MACAM,MAAM,GAAGC,SAAS,CAACsE,OAAnB;MACAtB,sBAAsB,GAAG,IAAzB;IACD;EACF;;EACD,OACK1C,uCAAI;IACPP,MADO;IAEPqC,eAFO;IAGPS,MAHO;IAIPE,kBAJO;IAKPC,sBALO;IAMPC,kBANO;IAOPC,eAPO;IAQPC,cARO;IASPC,QATO;IAUPC;EAVO,CAAJ,CADL;AAaD;;AAED,SAASkB,WAAT,CAAqBC,GAArB,EAA0B/E,IAA1B,EAAuC;EACrC,IAAI;IAAEgF,KAAF;IAAS1E,MAAT;IAAiBiD;EAAjB,IAA4CvD,IAAhD;;EAGA,IAAIiF,aAAa,CAACF,GAAD,CAAjB,EAAwB;IACtBC,KAAK,GAAGD,GAAR;IACAzE,MAAM,GAAGC,SAAS,CAAC2E,OAAnB;IACA3B,sBAAsB,GAAG,IAAzB;EACD,CAJD,MAIO;IAEL,MAAMwB,GAAN;EACD;;EAED,uCAAY/E,IAAZ,GAAkB;IAAAgF;IAAO1E,MAAP;IAAeiD;EAAf,CAAlB;AACD;;AAEM,eAAe4B,GAAf,CACLpF,UADK,EAEmB;EAAA,IAAxBN,OAAwB,uEAAF,EAAE;;;;EAExB,IAAIO,IAAI,GAAY;IAClBP,OADkB;IAElBE,MAAM,EAAEH,gBAAgB,CAACC,OAAD;EAFN,CAApB;EAKAO,IAAI,GAAGF,cAAc,CAACC,UAAD,EAAaC,IAAb,CAArB;;EACA,IAAI;IACFA,IAAI,GAAG,MAAMc,qBAAqB,CAACf,UAAD,EAAaC,IAAb,CAAlC;IACAA,IAAI,GAAG,MAAM+B,oBAAoB,CAAChC,UAAD,EAAaC,IAAb,CAAjC;EACD,CAHD,CAGE,OAAO+E,GAAP,EAAY;IACZ/E,IAAI,GAAG8E,WAAW,CAACC,GAAD,EAAM/E,IAAN,CAAlB;EACD;;EACDA,IAAI,GAAG,MAAMqD,YAAY,CAACtD,UAAD,EAAaC,IAAb,CAAzB;EAEA,MAAM;IACJsB,WADI;IAEJC,IAFI;IAGJ+B,kBAHI;IAIJC,sBAJI;IAKJC,kBALI;IAMJlD,MANI;IAOJmD,eAPI;IAQJC,cARI;IASJN,MATI;IAUJb,QAVI;IAWJoB,QAXI;IAYJqB,KAZI;IAaJrC;EAbI,IAcF3C,IAdJ;;EAgBA,IAAIuD,sBAAJ,EAA4B;IAC1BxD,UAAU,CAAC4B,kBAAX,CAA8BC,KAA9B,CAAoC;MAAE4B;IAAF,CAApC;EACD,CAFD,MAGK;IAEH4B,mBAAmB,CAACrF,UAAD,EAAkBc,uBAAlB,CAAnB;;IAEA,IAAIyC,kBAAJ,EAAwB;MAEtB,MAAM;QAAEjB,WAAW,EAAEgD,cAAf;QAA+BxB;MAA/B,IAAqDvC,WAA3D;MACAvB,UAAU,CAAC4B,kBAAX,CAA8B2D,eAA9B,CAA8C;QAC5CD,cAD4C;QAE5CxB,iBAF4C;QAG5C9C,WAAW,EAAE,iBAAY,CAACwE,OAAb,MAAoB,IAApB,IAAoBC,aAApB,GAAoB,MAApB,GAAoBA,GAAEzE,WAHS;QAI5CW,iBAAiB,EAAEH,IAAI,SAAJ,QAAI,KAAJ,sBAAI,CAAEG;MAJmB,CAA9C;IAMD;EACF;;EAGD,MAAM;IAAErB,OAAF;IAAWkF,OAAX;IAAoBE,eAApB;IAAqCC,OAArC;IAA8CrD,WAA9C;IAA2DwB,iBAA3D;IAA8EC;EAA9E,IAAyFxC,WAAW,IAAI,EAA9G;EACA;IACEhB,MAAM,EAAEA;EADV,GAEMiB,IAAI,IAAI;IAAEA;EAAF,CAFd,GAGMkC,eAAe,IAAI;IAAEA;EAAF,CAHzB,GAIMC,cAAc,IAAI;IAAEA;EAAF,CAJxB,GAKMN,MAAM,IAAI;IAAEA;EAAF,CALhB,GAMMb,QAAQ,IAAI;IAAEA;EAAF,CANlB,GAOMoB,QAAQ,IAAIA,QAAQ,CAACW,MAArB,IAA+B;IAAEX;EAAF,CAPrC,GAQMqB,KAAK,IAAI;IAAEA;EAAF,CARf,GASMlB,MAAM,IAAI;IAAEA;EAAF,CAThB,GAS0B;IACxBnB,eADwB;IAIxBtC,OAAO,EAAEA,OAJe;IAKxBkF,OAAO,EAAEA,OALe;IAMxBE,eAAe,EAAEA,eANO;IAOxBC,OAAO,EAAEA,OAPe;IAQxBrD,WAAW,EAAEA,WARW;IASxBwB;EATwB,CAT1B;AAoBF","names":["initializeValues","options","knownOptions","values","forEach","option","initializeData","authClient","data","idx","flow","withCredentials","remediators","actions","status","IdxStatus","PENDING","getFlow","setFlow","flowSpec","getFlowSpecification","Object","getDataFromIntrospect","stateHandle","version","state","scopes","recoveryToken","activationToken","maxAge","idxResponse","meta","getSavedTransactionMeta","introspect","interactionHandle","transactionManager","clear","interactResponse","interact","getDataFromRemediate","autoRemediate","step","shouldProceedWithEmailAuthenticator","useGenericRemediator","shouldRemediate","rawIdxState","idxResponseFromRemediation","nextStep","canceled","remediate","getTokens","interactionCode","clientId","codeVerifier","ignoreSignature","redirectUri","urls","tokenResponse","token","exchangeCodeForTokens","tokens","finalizeData","shouldSaveResponse","shouldClearTransaction","clearSharedStorage","enabledFeatures","availableSteps","messages","terminal","requestDidSucceed","stepUp","getEnabledFeatures","getAvailableSteps","getMessagesFromResponse","isTerminalResponse","TERMINAL","hasActions","keys","length","hasErrors","find","msg","class","isTerminalSuccess","CANCELED","SUCCESS","handleError","err","error","isIdxResponse","FAILURE","run","saveTransactionMeta","rawIdxResponse","saveIdxResponse","context","_a","neededToProceed","proceed"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\jobs-ui\\node_modules\\@okta\\lib\\idx\\run.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n\n/* eslint-disable max-statements, complexity, max-depth */\nimport { interact } from './interact';\nimport { introspect } from './introspect';\nimport { remediate } from './remediate';\nimport { getFlowSpecification } from './flow';\nimport * as remediators from './remediators';\nimport { \n  OktaAuthIdxInterface,\n  IdxStatus,\n  IdxTransaction,\n  IdxFeature,\n  NextStep,\n  RunOptions,\n  IdxTransactionMeta,\n  Tokens,\n  APIError,\n} from '../types';\nimport { IdxMessage, IdxResponse, isIdxResponse } from './types/idx-js';\nimport { getSavedTransactionMeta, saveTransactionMeta } from './transactionMeta';\nimport { getAvailableSteps, getEnabledFeatures, getMessagesFromResponse, isTerminalResponse } from './util';\ndeclare interface RunData {\n  options: RunOptions;\n  values: remediators.RemediationValues;\n  status?: IdxStatus;\n  tokens?: Tokens;\n  nextStep?: NextStep;\n  messages?: IdxMessage[];\n  error?: APIError | IdxResponse;\n  meta?: IdxTransactionMeta;\n  enabledFeatures?: IdxFeature[];\n  availableSteps?: NextStep[];\n  idxResponse?: IdxResponse;\n  canceled?: boolean;\n  interactionCode?: string;\n  shouldSaveResponse?: boolean;\n  shouldClearTransaction?: boolean;\n  clearSharedStorage?: boolean;\n  terminal?: boolean;\n}\n\nfunction initializeValues(options: RunOptions) {\n  // remove known options, everything else is assumed to be a value\n  const knownOptions = [\n    'flow', \n    'remediators', \n    'actions', \n    'withCredentials', \n    'step',\n    'useGenericRemediator',\n    'exchangeCodeForTokens',\n    'shouldProceedWithEmailAuthenticator'\n  ];\n  const values = { ...options };\n  knownOptions.forEach(option => {\n    delete values[option];\n  });\n  return values;\n}\n\nfunction initializeData(authClient, data: RunData): RunData {\n  let { options } = data;\n  options = {\n    ...authClient.options.idx,\n    ...options\n  };\n  let {\n    flow,\n    withCredentials,\n    remediators,\n    actions,\n  } = options;\n\n  const status = IdxStatus.PENDING;\n\n  // certain options can be set by the flow specification\n  flow = flow || authClient.idx.getFlow() || 'default';\n  if (flow) {\n    authClient.idx.setFlow(flow);\n    const flowSpec = getFlowSpecification(authClient, flow);\n    // Favor option values over flow spec\n    withCredentials = (typeof withCredentials !== 'undefined') ? withCredentials : flowSpec.withCredentials;\n    remediators = remediators || flowSpec.remediators;\n    actions = actions || flowSpec.actions;\n  }\n\n  return { \n    ...data,\n    options: { \n      ...options, \n      flow, \n      withCredentials, \n      remediators, \n      actions,\n    },\n    status\n  };\n}\n\nasync function getDataFromIntrospect(authClient, data: RunData): Promise<RunData> {\n  const { options } = data;\n  const {\n    stateHandle,\n    withCredentials,\n    version,\n    state,\n    scopes,\n    recoveryToken,\n    activationToken,\n    maxAge,\n  } = options;\n\n  let idxResponse;\n  let meta = getSavedTransactionMeta(authClient, { state, recoveryToken, activationToken }); // may be undefined\n\n  if (stateHandle) {\n    idxResponse = await introspect(authClient, { withCredentials, version, stateHandle });\n  } else {\n    let interactionHandle = meta?.interactionHandle; // may be undefined\n    if (!interactionHandle) {\n      // start a new transaction\n      authClient.transactionManager.clear();\n      const interactResponse = await interact(authClient, {\n        withCredentials,\n        state,\n        scopes,\n        activationToken,\n        recoveryToken,\n        maxAge,\n      }); \n      interactionHandle = interactResponse.interactionHandle;\n      meta = interactResponse.meta;\n    }\n  \n    // Introspect to get idx response\n    idxResponse = await introspect(authClient, { withCredentials, version, interactionHandle });\n  }\n  return { ...data, idxResponse, meta };\n}\n\nasync function getDataFromRemediate(authClient, data: RunData): Promise<RunData> {\n  let {\n    idxResponse,\n    options,\n    values\n  } = data;\n\n  const {\n    autoRemediate,\n    remediators,\n    actions,\n    flow,\n    step,\n    shouldProceedWithEmailAuthenticator, // will be removed in next major version\n    useGenericRemediator,\n  } = options;\n  \n  const shouldRemediate = (autoRemediate !== false && (remediators || actions || step));\n  if (!shouldRemediate) {\n    return data;\n  }\n\n  values = { \n    ...values, \n    stateHandle: idxResponse!.rawIdxState.stateHandle \n  };\n\n  // Can we handle the remediations?\n  const { \n    idxResponse: idxResponseFromRemediation, \n    nextStep,\n    canceled,\n  } = await remediate(\n    authClient,\n    idxResponse!, \n    values, \n    {\n      remediators,\n      actions,\n      flow,\n      step,\n      shouldProceedWithEmailAuthenticator, // will be removed in next major version\n      useGenericRemediator,\n    }\n  );\n  idxResponse = idxResponseFromRemediation;\n\n  return { ...data, idxResponse, nextStep, canceled };\n}\n\nasync function getTokens(authClient, data: RunData): Promise<Tokens> {\n  let { meta, idxResponse } = data;\n  const { interactionCode } = idxResponse as IdxResponse;\n  const {\n    clientId,\n    codeVerifier,\n    ignoreSignature,\n    redirectUri,\n    urls,\n    scopes,\n  } = meta as IdxTransactionMeta;\n  const tokenResponse = await authClient.token.exchangeCodeForTokens({\n    interactionCode,\n    clientId,\n    codeVerifier,\n    ignoreSignature,\n    redirectUri,\n    scopes\n  }, urls);\n  return tokenResponse.tokens;\n}\n\nasync function finalizeData(authClient, data: RunData): Promise<RunData> {\n  let {\n    options,\n    idxResponse,\n    canceled,\n    status,\n  } = data;\n  const { exchangeCodeForTokens } = options;\n  let shouldSaveResponse = false;\n  let shouldClearTransaction = false;\n  let clearSharedStorage = true;\n  let interactionCode;\n  let tokens;\n  let enabledFeatures;\n  let availableSteps;\n  let messages;\n  let terminal;\n\n  if (idxResponse) {\n    shouldSaveResponse = !!(idxResponse.requestDidSucceed || idxResponse.stepUp);\n    enabledFeatures = getEnabledFeatures(idxResponse);\n    availableSteps = getAvailableSteps(authClient, idxResponse, options.useGenericRemediator);\n    messages = getMessagesFromResponse(idxResponse, options);\n    terminal = isTerminalResponse(idxResponse);\n  }\n\n  if (terminal) {\n    status = IdxStatus.TERMINAL;\n\n    // In most cases a terminal response should not clear transaction data. The user should cancel or skip to continue.\n    // A terminal \"success\" is a non-error response with no further actions available.\n    // In these narrow cases, saved transaction data should be cleared.\n    // One example of a terminal success is when the email verify flow is continued in another tab\n    const hasActions = Object.keys(idxResponse!.actions).length > 0;\n    const hasErrors = !!messages.find(msg => msg.class === 'ERROR');\n    const isTerminalSuccess = !hasActions && !hasErrors && idxResponse!.requestDidSucceed === true;\n    if (isTerminalSuccess) {\n      shouldClearTransaction = true;\n    } else {\n      // only save response if there are actions available (ignore messages)\n      shouldSaveResponse = shouldSaveResponse && hasActions;\n    }\n    // leave shared storage intact so the transaction can be continued in another tab\n    clearSharedStorage = false;\n  } else if (canceled) {\n    status = IdxStatus.CANCELED;\n    shouldClearTransaction = true;\n  } else if (idxResponse?.interactionCode) { \n    interactionCode = idxResponse.interactionCode;\n    if (exchangeCodeForTokens === false) {\n      status = IdxStatus.SUCCESS;\n      shouldClearTransaction = false;\n    } else {\n      tokens = await getTokens(authClient, data);\n      status = IdxStatus.SUCCESS;\n      shouldClearTransaction = true;\n    }\n  }\n  return {\n    ...data,\n    status,\n    interactionCode,\n    tokens,\n    shouldSaveResponse,\n    shouldClearTransaction,\n    clearSharedStorage,\n    enabledFeatures,\n    availableSteps,\n    messages,\n    terminal\n  };\n}\n\nfunction handleError(err, data: RunData): RunData {\n  let { error, status, shouldClearTransaction } = data;\n\n  // current version of idx-js will throw/reject IDX responses. Handle these differently than regular errors\n  if (isIdxResponse(err)) {\n    error = err;\n    status = IdxStatus.FAILURE;\n    shouldClearTransaction = true;\n  } else {\n    // error is not an IDX response, throw it like a regular error\n    throw err;\n  }\n\n  return { ...data, error, status, shouldClearTransaction };\n}\n\nexport async function run(\n  authClient: OktaAuthIdxInterface, \n  options: RunOptions = {},\n): Promise<IdxTransaction> {\n  let data: RunData = {\n    options,\n    values: initializeValues(options)\n  };\n\n  data = initializeData(authClient, data);\n  try {\n    data = await getDataFromIntrospect(authClient, data);\n    data = await getDataFromRemediate(authClient, data);\n  } catch (err) {\n    data = handleError(err, data);\n  }\n  data = await finalizeData(authClient, data);\n\n  const {\n    idxResponse,\n    meta,\n    shouldSaveResponse,\n    shouldClearTransaction,\n    clearSharedStorage,\n    status,\n    enabledFeatures,\n    availableSteps,\n    tokens,\n    nextStep,\n    messages,\n    error,\n    interactionCode\n  } = data;\n\n  if (shouldClearTransaction) {\n    authClient.transactionManager.clear({ clearSharedStorage });\n  }\n  else {\n    // ensures state is saved to sessionStorage\n    saveTransactionMeta(authClient, { ...meta });\n\n    if (shouldSaveResponse) {\n      // Save intermediate idx response in storage to reduce introspect call\n      const { rawIdxState: rawIdxResponse, requestDidSucceed } = idxResponse!;\n      authClient.transactionManager.saveIdxResponse({\n        rawIdxResponse,\n        requestDidSucceed,\n        stateHandle: idxResponse!.context?.stateHandle,\n        interactionHandle: meta?.interactionHandle\n      });\n    }\n  }\n  \n  // copy all fields from idxResponse which are needed by the widget\n  const { actions, context, neededToProceed, proceed, rawIdxState, requestDidSucceed, stepUp } = idxResponse || {};\n  return {\n    status: status!,\n    ...(meta && { meta }),\n    ...(enabledFeatures && { enabledFeatures }),\n    ...(availableSteps && { availableSteps }),\n    ...(tokens && { tokens }),\n    ...(nextStep && { nextStep }),\n    ...(messages && messages.length && { messages }),\n    ...(error && { error }),\n    ...(stepUp && { stepUp }),\n    interactionCode, // if options.exchangeCodeForTokens is false\n\n    // from idx-js\n    actions: actions!,\n    context: context!,\n    neededToProceed: neededToProceed!,\n    proceed: proceed!,\n    rawIdxState: rawIdxState!,\n    requestDidSucceed\n  };\n}\n"]},"metadata":{},"sourceType":"module"}