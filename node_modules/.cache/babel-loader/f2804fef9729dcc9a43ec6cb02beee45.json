{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { getWellKnown } from '../endpoints/well-known.js';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport { getDefaultTokenParams } from './defaultTokenParams.js';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants.js';\nimport PKCE from './pkce.js';\n\nfunction assertPKCESupport(sdk) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n\n    if (!sdk.features.isHTTPS()) {\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n\n    if (!sdk.features.hasTextEncoder()) {\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nfunction validateCodeChallengeMethod(_x, _x2) {\n  return _validateCodeChallengeMethod.apply(this, arguments);\n}\n\nfunction _validateCodeChallengeMethod() {\n  _validateCodeChallengeMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sdk, codeChallengeMethod) {\n    var wellKnownResponse, methods;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n            _context.next = 3;\n            return getWellKnown(sdk);\n\n          case 3:\n            wellKnownResponse = _context.sent;\n            methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n\n            if (!(methods.indexOf(codeChallengeMethod) === -1)) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new AuthSdkError('Invalid code_challenge_method');\n\n          case 7:\n            return _context.abrupt(\"return\", codeChallengeMethod);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _validateCodeChallengeMethod.apply(this, arguments);\n}\n\nfunction preparePKCE(_x3, _x4) {\n  return _preparePKCE.apply(this, arguments);\n}\n\nfunction _preparePKCE() {\n  _preparePKCE = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(sdk, tokenParams) {\n    var _tokenParams, codeVerifier, codeChallenge, codeChallengeMethod;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _tokenParams = tokenParams, codeVerifier = _tokenParams.codeVerifier, codeChallenge = _tokenParams.codeChallenge, codeChallengeMethod = _tokenParams.codeChallengeMethod;\n            codeChallenge = codeChallenge || sdk.options.codeChallenge;\n\n            if (codeChallenge) {\n              _context2.next = 8;\n              break;\n            }\n\n            assertPKCESupport(sdk);\n            codeVerifier = codeVerifier || PKCE.generateVerifier();\n            _context2.next = 7;\n            return PKCE.computeChallenge(codeVerifier);\n\n          case 7:\n            codeChallenge = _context2.sent;\n\n          case 8:\n            _context2.next = 10;\n            return validateCodeChallengeMethod(sdk, codeChallengeMethod);\n\n          case 10:\n            codeChallengeMethod = _context2.sent;\n            tokenParams = Object.assign(Object.assign({}, tokenParams), {\n              responseType: 'code',\n              codeVerifier: codeVerifier,\n              codeChallenge: codeChallenge,\n              codeChallengeMethod: codeChallengeMethod\n            });\n            return _context2.abrupt(\"return\", tokenParams);\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _preparePKCE.apply(this, arguments);\n}\n\nfunction prepareTokenParams(_x5) {\n  return _prepareTokenParams.apply(this, arguments);\n}\n\nfunction _prepareTokenParams() {\n  _prepareTokenParams = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(sdk) {\n    var tokenParams,\n        defaults,\n        _args3 = arguments;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            tokenParams = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            defaults = getDefaultTokenParams(sdk);\n            tokenParams = Object.assign(Object.assign({}, defaults), tokenParams);\n\n            if (!(tokenParams.pkce === false)) {\n              _context3.next = 5;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", tokenParams);\n\n          case 5:\n            return _context3.abrupt(\"return\", preparePKCE(sdk, tokenParams));\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _prepareTokenParams.apply(this, arguments);\n}\n\nexport { assertPKCESupport, preparePKCE, prepareTokenParams, validateCodeChallengeMethod };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;AAoBM,SAAUA,iBAAV,CAA4BC,GAA5B,EAA0D;EAC9D,IAAI,CAACA,GAAG,CAACC,QAAJ,CAAaC,eAAb,EAAL,EAAqC;IACnC,IAAIC,YAAY,GAAG,qFAAnB;;IACA,IAAI,CAACH,GAAG,CAACC,QAAJ,CAAaG,OAAb,EAAL,EAA6B;MAE3BD,YAAY,IAAI,kGAAhB;IACD;;IACD,IAAI,CAACH,GAAG,CAACC,QAAJ,CAAaI,cAAb,EAAL,EAAoC;MAElCF,YAAY,IAAI,wGAAhB;IACD;;IACD,MAAM,IAAIG,YAAJ,CAAiBH,YAAjB,CAAN;EACD;AACF;;SAEqBI,2B;;;;;4FAAf,iBAA2CP,GAA3C,EAAuEQ,mBAAvE;IAAA;IAAA;MAAA;QAAA;UAAA;YAELA,mBAAmB,GAAGA,mBAAmB,IAAIR,GAAG,CAACS,OAAJ,CAAYD,mBAAnC,IAA0DE,6BAAhF;YAFK;YAAA,OAK2BC,YAAY,CAACX,GAAD,CALvC;;UAAA;YAKCY,iBALD;YAMDC,OANC,GAMSD,iBAAiB,CAAC,kCAAD,CAAjB,IAAyD,EANlE;;YAAA,MAODC,OAAO,CAACC,OAAR,CAAgBN,mBAAhB,MAAyC,CAAC,CAPzC;cAAA;cAAA;YAAA;;YAAA,MAQG,IAAIF,YAAJ,CAAiB,+BAAjB,CARH;;UAAA;YAAA,iCAUEE,mBAVF;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;SAaeO,W;;;;;4EAAf,kBACLf,GADK,EAELgB,WAFK;IAAA;;IAAA;MAAA;QAAA;UAAA;YAAA,eAQDA,WARC,EAKHC,YALG,gBAKHA,YALG,EAMHC,aANG,gBAMHA,aANG,EAOHV,mBAPG,gBAOHA,mBAPG;YAWLU,aAAa,GAAGA,aAAa,IAAIlB,GAAG,CAACS,OAAJ,CAAYS,aAA7C;;YAXK,IAYAA,aAZA;cAAA;cAAA;YAAA;;YAaHnB,iBAAiB,CAACC,GAAD,CAAjB;YACAiB,YAAY,GAAGA,YAAY,IAAIE,IAAI,CAACC,gBAAL,EAA/B;YAdG;YAAA,OAemBD,IAAI,CAACE,gBAAL,CAAsBJ,YAAtB,CAfnB;;UAAA;YAeHC,aAfG;;UAAA;YAAA;YAAA,OAiBuBX,2BAA2B,CAACP,GAAD,EAAMQ,mBAAN,CAjBlD;;UAAA;YAiBLA,mBAjBK;YAoBLQ,WAAW,mCACNA,WADM,GACK;cACdM,YAAY,EAAE,MADA;cAEdL,YAAY,EAAZA,YAFc;cAGdC,aAAa,EAAbA,aAHc;cAIdV,mBAAmB,EAAnBA;YAJc,CADL,CAAX;YApBK,kCA4BEQ,WA5BF;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;SAgCeO,kB;;;;;mFAAf,kBACLvB,GADK;IAAA;IAAA;IAAA;IAAA;MAAA;QAAA;UAAA;YAELgB,WAFK,8DAEsB,EAFtB;YAKCQ,QALD,GAKYC,qBAAqB,CAACzB,GAAD,CALjC;YAMLgB,WAAW,GAAQU,2CAAaV,WAAb,CAAnB;;YANK,MAQDA,WAAW,CAACW,IAAZ,KAAqB,KARpB;cAAA;cAAA;YAAA;;YAAA,kCAUIX,WAVJ;;UAAA;YAAA,kCAaED,WAAW,CAACf,GAAD,EAAMgB,WAAN,CAbb;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C","names":["assertPKCESupport","sdk","features","isPKCESupported","errorMessage","isHTTPS","hasTextEncoder","AuthSdkError","validateCodeChallengeMethod","codeChallengeMethod","options","DEFAULT_CODE_CHALLENGE_METHOD","getWellKnown","wellKnownResponse","methods","indexOf","preparePKCE","tokenParams","codeVerifier","codeChallenge","PKCE","generateVerifier","computeChallenge","responseType","prepareTokenParams","defaults","getDefaultTokenParams","Object","pkce"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\oidc\\util\\prepareTokenParams.ts"],"sourcesContent":["/* eslint-disable complexity */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { getWellKnown } from '../endpoints/well-known';\nimport { AuthSdkError } from '../../errors';\nimport { OktaAuthFeaturesInterface, OktaAuthOIDCInterface, TokenParams } from '../../types';\nimport { getDefaultTokenParams } from './defaultTokenParams';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants';\nimport PKCE from './pkce';\n\nexport function assertPKCESupport(sdk: OktaAuthFeaturesInterface) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n    if (!sdk.features.isHTTPS()) {\n      // eslint-disable-next-line max-len\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n    if (!sdk.features.hasTextEncoder()) {\n      // eslint-disable-next-line max-len\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nexport async function validateCodeChallengeMethod(sdk: OktaAuthOIDCInterface, codeChallengeMethod?: string) {\n  // set default code challenge method, if none provided\n  codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n\n  // validate against .well-known/openid-configuration\n  const wellKnownResponse = await getWellKnown(sdk);\n  var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n  if (methods.indexOf(codeChallengeMethod) === -1) {\n    throw new AuthSdkError('Invalid code_challenge_method');\n  }\n  return codeChallengeMethod;\n}\n\nexport async function preparePKCE(\n  sdk: OktaAuthOIDCInterface, \n  tokenParams: TokenParams\n): Promise<TokenParams> {\n  let {\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  } = tokenParams;\n\n  // PKCE calculations can be avoided by passing a codeChallenge\n  codeChallenge = codeChallenge || sdk.options.codeChallenge;\n  if (!codeChallenge) {\n    assertPKCESupport(sdk);\n    codeVerifier = codeVerifier || PKCE.generateVerifier();\n    codeChallenge = await PKCE.computeChallenge(codeVerifier);\n  }\n  codeChallengeMethod = await validateCodeChallengeMethod(sdk, codeChallengeMethod);\n\n  // Clone/copy the params. Set PKCE values\n  tokenParams = {\n    ...tokenParams,\n    responseType: 'code', // responseType is forced\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  };\n\n  return tokenParams;\n}\n\n// Prepares params for a call to /authorize or /token\nexport async function prepareTokenParams(\n  sdk: OktaAuthOIDCInterface,\n  tokenParams: TokenParams = {}\n): Promise<TokenParams> {\n  // build params using defaults + options\n  const defaults = getDefaultTokenParams(sdk);\n  tokenParams = { ...defaults, ...tokenParams };\n\n  if (tokenParams.pkce === false) {\n    // Implicit flow or authorization_code without PKCE\n    return tokenParams;\n  }\n\n  return preparePKCE(sdk, tokenParams);\n}"]},"metadata":{},"sourceType":"module"}