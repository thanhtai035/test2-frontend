{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet =\n/** @class */\nfunction () {\n  function ObliviousSet(ttl) {\n    this.ttl = ttl;\n    this.map = new Map();\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n\n    this._to = false;\n  }\n\n  ObliviousSet.prototype.has = function (value) {\n    return this.map.has(value);\n  };\n\n  ObliviousSet.prototype.add = function (value) {\n    var _this = this;\n\n    this.map.set(value, now());\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n\n    if (!this._to) {\n      this._to = true;\n      setTimeout(function () {\n        _this._to = false;\n        removeTooOldValues(_this);\n      }, 0);\n    }\n  };\n\n  ObliviousSet.prototype.clear = function () {\n    this.map.clear();\n  };\n\n  return ObliviousSet;\n}();\n\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\n\nexport function removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.map[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n\n  while (true) {\n    var next = iterator.next().value;\n\n    if (!next) {\n      return; // no more elements\n    }\n\n    var value = next[0];\n    var time = next[1];\n\n    if (time < olderThen) {\n      obliviousSet.map.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return new Date().getTime();\n}","map":{"version":3,"mappings":"AACA;;;;;AAKA;AAAA;AAAA;EAQI,sBACoBA,GADpB,EAC+B;IAAX;IARJ,WAAM,IAAIC,GAAJ,EAAN;IAEhB;;;;;IAIO,WAAe,KAAf;EAGF;;EAELC,uCAAIC,KAAJ,EAAY;IACR,OAAO,KAAKC,GAAL,CAASC,GAAT,CAAaF,KAAb,CAAP;EACH,CAFD;;EAIAD,uCAAIC,KAAJ,EAAY;IAAZ;;IACI,KAAKC,GAAL,CAASE,GAAT,CAAaH,KAAb,EAAoBI,GAAG,EAAvB;IAEA;;;;;;;IAMA,IAAI,CAAC,KAAKC,GAAV,EAAe;MACX,KAAKA,GAAL,GAAW,IAAX;MACAC,UAAU,CAAC;QACPC,KAAI,CAACF,GAAL,GAAW,KAAX;QACAG,kBAAkB,CAACD,KAAD,CAAlB;MACH,CAHS,EAGP,CAHO,CAAV;IAIH;EACJ,CAhBD;;EAkBAR;IACI,KAAKE,GAAL,CAASQ,KAAT;EACH,CAFD;;EAGJ;AAAC,CArCD;;;AAwCA;;;;;AAIA,OAAM,SAAUD,kBAAV,CACFE,YADE,EACwB;EAE1B,IAAMC,SAAS,GAAGP,GAAG,KAAKM,YAAY,CAACb,GAAvC;EACA,IAAMe,QAAQ,GAAGF,YAAY,CAACT,GAAb,CAAiBY,MAAM,CAACD,QAAxB,GAAjB;EAEA;;;;;EAIA,OAAO,IAAP,EAAa;IAET,IAAME,IAAI,GAAGF,QAAQ,CAACE,IAAT,GAAgBd,KAA7B;;IAEA,IAAI,CAACc,IAAL,EAAW;MACP,OADO,CACC;IACX;;IACD,IAAMd,KAAK,GAAGc,IAAI,CAAC,CAAD,CAAlB;IACA,IAAMC,IAAI,GAAGD,IAAI,CAAC,CAAD,CAAjB;;IACA,IAAIC,IAAI,GAAGJ,SAAX,EAAsB;MAClBD,YAAY,CAACT,GAAb,CAAiBe,MAAjB,CAAwBhB,KAAxB;IACH,CAFD,MAEO;MACH;MACA;IACH;EACJ;AACJ;AAED,OAAM,SAAUI,GAAV,GAAa;EACf,OAAO,IAAIa,IAAJ,GAAWC,OAAX,EAAP;AACH","names":["ttl","Map","ObliviousSet","value","map","has","set","now","_to","setTimeout","_this","removeTooOldValues","clear","obliviousSet","olderThen","iterator","Symbol","next","time","delete","Date","getTime"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\oblivious-set\\src\\index.ts"],"sourcesContent":["\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet<T = any> {\n    public readonly map = new Map();\n\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    public _to: boolean = false;\n    constructor(\n        public readonly ttl: number\n    ) { }\n\n    has(value: T): boolean {\n        return this.map.has(value);\n    }\n\n    add(value: T): void {\n        this.map.set(value, now());\n\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(() => {\n                this._to = false;\n                removeTooOldValues(this);\n            }, 0);\n        }\n    }\n\n    clear() {\n        this.map.clear();\n    }\n}\n\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(\n    obliviousSet: ObliviousSet\n) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.map[Symbol.iterator]();\n\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n\n        const next = iterator.next().value;\n\n        if (!next) {\n            return; // no more elements\n        }\n        const value = next[0];\n        const time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        } else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\n\nexport function now(): number {\n    return new Date().getTime();\n}\n\n\n"]},"metadata":{},"sourceType":"module"}