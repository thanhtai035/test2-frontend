{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getRemediator, handleIdxError, isTerminalResponse, filterValuesForRemediation, getNextStep } from './util.js';\n\nfunction getActionFromValues(values, idxResponse) {\n  return Object.keys(idxResponse.actions).find(function (action) {\n    return !!values.resend && action.includes('-resend');\n  });\n}\n\nfunction removeActionFromValues(values) {\n  return Object.assign(Object.assign({}, values), {\n    resend: undefined\n  });\n}\n\nfunction removeActionFromOptions(options, actionName) {\n  var actions = options.actions || [];\n  actions = actions.filter(function (entry) {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n\n    return entry.name !== actionName;\n  });\n  return Object.assign(Object.assign({}, options), {\n    actions: actions\n  });\n}\n\nfunction remediate(_x, _x2, _x3, _x4) {\n  return _remediate.apply(this, arguments);\n}\n\nfunction _remediate() {\n  _remediate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authClient, idxResponse, values, options) {\n    var _idxResponse, neededToProceed, interactionCode, _options, flow, remediator, actionFromValues, actionFromOptions, actions, _iterator, _step, _loop, _ret, terminal, nextStep, name, data, gr, _nextStep;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _idxResponse = idxResponse, neededToProceed = _idxResponse.neededToProceed, interactionCode = _idxResponse.interactionCode;\n            _options = options, flow = _options.flow;\n\n            if (!interactionCode) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              idxResponse: idxResponse\n            });\n\n          case 4:\n            remediator = getRemediator(neededToProceed, values, options);\n            actionFromValues = getActionFromValues(values, idxResponse);\n            actionFromOptions = options.actions || [];\n            actions = [].concat(_toConsumableArray(actionFromOptions), _toConsumableArray(actionFromValues && [actionFromValues] || []));\n\n            if (!actions) {\n              _context2.next = 28;\n              break;\n            }\n\n            _iterator = _createForOfIteratorHelper(actions);\n            _context2.prev = 10;\n            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n              var action, params, valuesWithoutExecutedAction, optionsWithoutExecutedAction, remediationAction;\n              return _regeneratorRuntime().wrap(function _loop$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      action = _step.value;\n                      params = {};\n\n                      if (typeof action !== 'string') {\n                        params = action.params || {};\n                        action = action.name;\n                      }\n\n                      valuesWithoutExecutedAction = removeActionFromValues(values);\n                      optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n\n                      if (!(typeof idxResponse.actions[action] === 'function')) {\n                        _context.next = 19;\n                        break;\n                      }\n\n                      _context.prev = 6;\n                      _context.next = 9;\n                      return idxResponse.actions[action](params);\n\n                    case 9:\n                      idxResponse = _context.sent;\n                      idxResponse = Object.assign(Object.assign({}, idxResponse), {\n                        requestDidSucceed: true\n                      });\n                      _context.next = 16;\n                      break;\n\n                    case 13:\n                      _context.prev = 13;\n                      _context.t0 = _context[\"catch\"](6);\n                      return _context.abrupt(\"return\", {\n                        v: handleIdxError(authClient, _context.t0, options)\n                      });\n\n                    case 16:\n                      if (!(action === 'cancel')) {\n                        _context.next = 18;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: {\n                          idxResponse: idxResponse,\n                          canceled: true\n                        }\n                      });\n\n                    case 18:\n                      return _context.abrupt(\"return\", {\n                        v: remediate(authClient, idxResponse, valuesWithoutExecutedAction, optionsWithoutExecutedAction)\n                      });\n\n                    case 19:\n                      remediationAction = neededToProceed.find(function (_ref) {\n                        var name = _ref.name;\n                        return name === action;\n                      });\n\n                      if (!remediationAction) {\n                        _context.next = 32;\n                        break;\n                      }\n\n                      _context.prev = 21;\n                      _context.next = 24;\n                      return idxResponse.proceed(action, params);\n\n                    case 24:\n                      idxResponse = _context.sent;\n                      idxResponse = Object.assign(Object.assign({}, idxResponse), {\n                        requestDidSucceed: true\n                      });\n                      _context.next = 31;\n                      break;\n\n                    case 28:\n                      _context.prev = 28;\n                      _context.t1 = _context[\"catch\"](21);\n                      return _context.abrupt(\"return\", {\n                        v: handleIdxError(authClient, _context.t1, options)\n                      });\n\n                    case 31:\n                      return _context.abrupt(\"return\", {\n                        v: remediate(authClient, idxResponse, values, optionsWithoutExecutedAction)\n                      });\n\n                    case 32:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _loop, null, [[6, 13], [21, 28]]);\n            });\n\n            _iterator.s();\n\n          case 13:\n            if ((_step = _iterator.n()).done) {\n              _context2.next = 20;\n              break;\n            }\n\n            return _context2.delegateYield(_loop(), \"t0\", 15);\n\n          case 15:\n            _ret = _context2.t0;\n\n            if (!(typeof _ret === \"object\")) {\n              _context2.next = 18;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _ret.v);\n\n          case 18:\n            _context2.next = 13;\n            break;\n\n          case 20:\n            _context2.next = 25;\n            break;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t1 = _context2[\"catch\"](10);\n\n            _iterator.e(_context2.t1);\n\n          case 25:\n            _context2.prev = 25;\n\n            _iterator.f();\n\n            return _context2.finish(25);\n\n          case 28:\n            terminal = isTerminalResponse(idxResponse);\n\n            if (!terminal) {\n              _context2.next = 31;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              idxResponse: idxResponse,\n              terminal: terminal\n            });\n\n          case 31:\n            if (remediator) {\n              _context2.next = 48;\n              break;\n            }\n\n            if (!options.step) {\n              _context2.next = 45;\n              break;\n            }\n\n            values = filterValuesForRemediation(idxResponse, options.step, values);\n            _context2.prev = 34;\n            _context2.next = 37;\n            return idxResponse.proceed(options.step, values);\n\n          case 37:\n            idxResponse = _context2.sent;\n            idxResponse = Object.assign(Object.assign({}, idxResponse), {\n              requestDidSucceed: true\n            });\n            return _context2.abrupt(\"return\", {\n              idxResponse: idxResponse\n            });\n\n          case 42:\n            _context2.prev = 42;\n            _context2.t2 = _context2[\"catch\"](34);\n            return _context2.abrupt(\"return\", handleIdxError(authClient, _context2.t2, options));\n\n          case 45:\n            if (!(flow === 'default')) {\n              _context2.next = 47;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              idxResponse: idxResponse\n            });\n\n          case 47:\n            throw new AuthSdkError(\"\\n      No remediation can match current flow, check policy settings in your org.\\n      Remediations: [\".concat(neededToProceed.reduce(function (acc, curr) {\n              return acc ? acc + ' ,' + curr.name : curr.name;\n            }, ''), \"]\\n    \"));\n\n          case 48:\n            if (remediator.canRemediate()) {\n              _context2.next = 51;\n              break;\n            }\n\n            nextStep = getNextStep(authClient, remediator, idxResponse);\n            return _context2.abrupt(\"return\", {\n              idxResponse: idxResponse,\n              nextStep: nextStep\n            });\n\n          case 51:\n            name = remediator.getName();\n            data = remediator.getData();\n            _context2.prev = 53;\n            _context2.next = 56;\n            return idxResponse.proceed(name, data);\n\n          case 56:\n            idxResponse = _context2.sent;\n            idxResponse = Object.assign(Object.assign({}, idxResponse), {\n              requestDidSucceed: true\n            });\n            values = remediator.getValuesAfterProceed();\n            options = Object.assign(Object.assign({}, options), {\n              step: undefined\n            });\n\n            if (!(options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse))) {\n              _context2.next = 64;\n              break;\n            }\n\n            gr = getRemediator(idxResponse.neededToProceed, values, options);\n            _nextStep = getNextStep(authClient, gr, idxResponse);\n            return _context2.abrupt(\"return\", {\n              idxResponse: idxResponse,\n              nextStep: _nextStep\n            });\n\n          case 64:\n            return _context2.abrupt(\"return\", remediate(authClient, idxResponse, values, options));\n\n          case 67:\n            _context2.prev = 67;\n            _context2.t3 = _context2[\"catch\"](53);\n            return _context2.abrupt(\"return\", handleIdxError(authClient, _context2.t3, options));\n\n          case 70:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[10, 22, 25, 28], [34, 42], [53, 67]]);\n  }));\n  return _remediate.apply(this, arguments);\n}\n\nexport { remediate };","map":{"version":3,"mappings":"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","names":["getActionFromValues","values","idxResponse","Object","keys","actions","find","resend","action","includes","removeActionFromValues","undefined","removeActionFromOptions","options","actionName","filter","entry","name","remediate","authClient","neededToProceed","interactionCode","flow","remediator","getRemediator","actionFromValues","actionFromOptions","params","valuesWithoutExecutedAction","optionsWithoutExecutedAction","requestDidSucceed","handleIdxError","canceled","remediationAction","proceed","terminal","isTerminalResponse","step","filterValuesForRemediation","AuthSdkError","reduce","acc","curr","canRemediate","nextStep","getNextStep","getName","data","getData","getValuesAfterProceed","useGenericRemediator","gr"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\idx\\remediate.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n\n/* eslint-disable max-statements, max-depth, complexity */\nimport { OktaAuthIdxInterface } from '../types';\nimport { AuthSdkError } from '../errors';\nimport { RemediationValues } from './remediators';\nimport { RemediateOptions, RemediationResponse } from './types';\nimport { \n  IdxResponse,\n  IdxActionParams, \n} from './types/idx-js';\nimport {\n  isTerminalResponse,\n  filterValuesForRemediation,\n  getRemediator,\n  getNextStep,\n  handleIdxError\n} from './util';\n\nexport interface RemediateActionWithOptionalParams {\n  name: string;\n  params?: IdxActionParams;\n}\n\nexport type RemediateAction = string | RemediateActionWithOptionalParams;\n\n\nfunction getActionFromValues(values: RemediationValues, idxResponse: IdxResponse): string | undefined {\n  // Currently support resend actions only\n  return Object.keys(idxResponse.actions).find(action => !!values.resend && action.includes('-resend'));\n}\n\nfunction removeActionFromValues(values: RemediationValues): RemediationValues {\n  // Currently support resend actions only\n  return {\n    ...values,\n    resend: undefined\n  };\n}\n\nfunction removeActionFromOptions(options: RemediateOptions, actionName: string): RemediateOptions {\n  let actions = options.actions || [];\n  actions = actions.filter(entry => {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n    return entry.name !== actionName;\n  });\n\n  return { ...options, actions };\n}\n\n// This function is called recursively until it reaches success or cannot be remediated\nexport async function remediate(\n  authClient: OktaAuthIdxInterface,\n  idxResponse: IdxResponse,\n  values: RemediationValues,\n  options: RemediateOptions\n): Promise<RemediationResponse> {\n  let { neededToProceed, interactionCode } = idxResponse;\n  const { flow } = options;\n\n  // If the response contains an interaction code, there is no need to remediate\n  if (interactionCode) {\n    return { idxResponse };\n  }\n\n  const remediator = getRemediator(neededToProceed, values, options);\n\n  // Try actions in idxResponse first\n  const actionFromValues = getActionFromValues(values, idxResponse);\n  const actionFromOptions = options.actions || [];\n  const actions = [\n    ...actionFromOptions,\n    ...(actionFromValues && [actionFromValues] || []),\n  ];\n  if (actions) {\n    for (let action of actions) {\n      // Action can either be specified as a string, or as an object with name and optional params\n      let params: IdxActionParams = {};\n      if (typeof action !== 'string') {\n        params = action.params || {};\n        action = action.name;\n      }\n      let valuesWithoutExecutedAction = removeActionFromValues(values);\n      let optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n\n      if (typeof idxResponse.actions[action] === 'function') {\n        try {\n          idxResponse = await idxResponse.actions[action](params);\n          idxResponse = { ...idxResponse, requestDidSucceed: true };\n        } catch (e) {\n          return handleIdxError(authClient, e, options);\n        }\n        if (action === 'cancel') {\n          return { idxResponse, canceled: true };\n        }\n        return remediate(\n          authClient, \n          idxResponse, \n          valuesWithoutExecutedAction, \n          optionsWithoutExecutedAction\n        ); // recursive call\n      }\n\n      // search for action in remediation list\n      const remediationAction = neededToProceed.find(({ name }) => name === action);\n      if (remediationAction) {\n        try {\n          idxResponse = await idxResponse.proceed(action, params);\n          idxResponse = { ...idxResponse, requestDidSucceed: true };\n        }\n        catch (e) {\n          return handleIdxError(authClient, e, options);\n        }\n\n        return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction); // recursive call\n      }\n    }\n  }\n\n  // Do not attempt to remediate if response is in terminal state\n  const terminal = isTerminalResponse(idxResponse);\n  if (terminal) {\n    return { idxResponse, terminal };\n  }\n\n  if (!remediator) {\n    if (options.step) {\n      values = filterValuesForRemediation(idxResponse, options.step, values); // include only requested values\n      try {\n        idxResponse = await idxResponse.proceed(options.step, values);\n        idxResponse = { ...idxResponse, requestDidSucceed: true };\n        return { idxResponse };\n      } catch(e) {\n        return handleIdxError(authClient, e, options);\n      }\n    }\n    if (flow === 'default') {\n      return { idxResponse };\n    }\n    throw new AuthSdkError(`\n      No remediation can match current flow, check policy settings in your org.\n      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + ' ,' + curr.name : curr.name, '')}]\n    `);\n  }\n\n  // Return next step to the caller\n  if (!remediator.canRemediate()) {\n    const nextStep = getNextStep(authClient, remediator, idxResponse);\n    return {\n      idxResponse,\n      nextStep,\n    };\n  }\n\n  const name = remediator.getName();\n  const data = remediator.getData();\n  try {\n    idxResponse = await idxResponse.proceed(name, data);\n    idxResponse = { ...idxResponse, requestDidSucceed: true };\n    // We may want to trim the values bag for the next remediation\n    // Let the remediator decide what the values should be (default to current values)\n    values = remediator.getValuesAfterProceed();\n    options = { ...options, step: undefined }; // do not re-use the step\n\n    // generic remediator should not auto proceed in pending status\n    // return nextStep directly\n    if (options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const gr = getRemediator(idxResponse.neededToProceed, values, options)!;\n      const nextStep = getNextStep(authClient, gr, idxResponse);\n      return {\n        idxResponse,\n        nextStep,\n      };\n    }\n    \n    return remediate(authClient, idxResponse, values, options); // recursive call\n  } catch (e) {\n    return handleIdxError(authClient, e, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}