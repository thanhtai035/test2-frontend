{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getRemediator, handleIdxError, isTerminalResponse, filterValuesForRemediation, getNextStep } from './util.js';\n\nfunction getActionFromValues(values, idxResponse) {\n  return Object.keys(idxResponse.actions).find(action => !!values.resend && action.includes('-resend'));\n}\n\nfunction removeActionFromValues(values) {\n  return Object.assign(Object.assign({}, values), {\n    resend: undefined\n  });\n}\n\nfunction removeActionFromOptions(options, actionName) {\n  let actions = options.actions || [];\n  actions = actions.filter(entry => {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n\n    return entry.name !== actionName;\n  });\n  return Object.assign(Object.assign({}, options), {\n    actions\n  });\n}\n\nasync function remediate(authClient, idxResponse, values, options) {\n  let {\n    neededToProceed,\n    interactionCode\n  } = idxResponse;\n  const {\n    flow\n  } = options;\n\n  if (interactionCode) {\n    return {\n      idxResponse\n    };\n  }\n\n  const remediator = getRemediator(neededToProceed, values, options);\n  const actionFromValues = getActionFromValues(values, idxResponse);\n  const actionFromOptions = options.actions || [];\n  const actions = [...actionFromOptions, ...(actionFromValues && [actionFromValues] || [])];\n\n  if (actions) {\n    for (let action of actions) {\n      let params = {};\n\n      if (typeof action !== 'string') {\n        params = action.params || {};\n        action = action.name;\n      }\n\n      let valuesWithoutExecutedAction = removeActionFromValues(values);\n      let optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n\n      if (typeof idxResponse.actions[action] === 'function') {\n        try {\n          idxResponse = await idxResponse.actions[action](params);\n          idxResponse = Object.assign(Object.assign({}, idxResponse), {\n            requestDidSucceed: true\n          });\n        } catch (e) {\n          return handleIdxError(authClient, e, options);\n        }\n\n        if (action === 'cancel') {\n          return {\n            idxResponse,\n            canceled: true\n          };\n        }\n\n        return remediate(authClient, idxResponse, valuesWithoutExecutedAction, optionsWithoutExecutedAction);\n      }\n\n      const remediationAction = neededToProceed.find(_ref => {\n        let {\n          name\n        } = _ref;\n        return name === action;\n      });\n\n      if (remediationAction) {\n        try {\n          idxResponse = await idxResponse.proceed(action, params);\n          idxResponse = Object.assign(Object.assign({}, idxResponse), {\n            requestDidSucceed: true\n          });\n        } catch (e) {\n          return handleIdxError(authClient, e, options);\n        }\n\n        return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction);\n      }\n    }\n  }\n\n  const terminal = isTerminalResponse(idxResponse);\n\n  if (terminal) {\n    return {\n      idxResponse,\n      terminal\n    };\n  }\n\n  if (!remediator) {\n    if (options.step) {\n      values = filterValuesForRemediation(idxResponse, options.step, values);\n\n      try {\n        idxResponse = await idxResponse.proceed(options.step, values);\n        idxResponse = Object.assign(Object.assign({}, idxResponse), {\n          requestDidSucceed: true\n        });\n        return {\n          idxResponse\n        };\n      } catch (e) {\n        return handleIdxError(authClient, e, options);\n      }\n    }\n\n    if (flow === 'default') {\n      return {\n        idxResponse\n      };\n    }\n\n    throw new AuthSdkError(`\n      No remediation can match current flow, check policy settings in your org.\n      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + ' ,' + curr.name : curr.name, '')}]\n    `);\n  }\n\n  if (!remediator.canRemediate()) {\n    const nextStep = getNextStep(authClient, remediator, idxResponse);\n    return {\n      idxResponse,\n      nextStep\n    };\n  }\n\n  const name = remediator.getName();\n  const data = remediator.getData();\n\n  try {\n    idxResponse = await idxResponse.proceed(name, data);\n    idxResponse = Object.assign(Object.assign({}, idxResponse), {\n      requestDidSucceed: true\n    });\n    values = remediator.getValuesAfterProceed();\n    options = Object.assign(Object.assign({}, options), {\n      step: undefined\n    });\n\n    if (options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {\n      const gr = getRemediator(idxResponse.neededToProceed, values, options);\n      const nextStep = getNextStep(authClient, gr, idxResponse);\n      return {\n        idxResponse,\n        nextStep\n      };\n    }\n\n    return remediate(authClient, idxResponse, values, options);\n  } catch (e) {\n    return handleIdxError(authClient, e, options);\n  }\n}\n\nexport { remediate };","map":{"version":3,"mappings":"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","names":["getActionFromValues","values","idxResponse","Object","keys","actions","find","action","resend","includes","removeActionFromValues","undefined","removeActionFromOptions","options","actionName","filter","entry","name","remediate","authClient","neededToProceed","interactionCode","flow","remediator","getRemediator","actionFromValues","actionFromOptions","params","valuesWithoutExecutedAction","optionsWithoutExecutedAction","requestDidSucceed","e","handleIdxError","canceled","remediationAction","proceed","terminal","isTerminalResponse","step","filterValuesForRemediation","AuthSdkError","reduce","acc","curr","canRemediate","nextStep","getNextStep","getName","data","getData","getValuesAfterProceed","useGenericRemediator","gr"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\jobs-ui\\node_modules\\@okta\\lib\\idx\\remediate.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n\n/* eslint-disable max-statements, max-depth, complexity */\nimport { OktaAuthIdxInterface } from '../types';\nimport { AuthSdkError } from '../errors';\nimport { RemediationValues } from './remediators';\nimport { RemediateOptions, RemediationResponse } from './types';\nimport { \n  IdxResponse,\n  IdxActionParams, \n} from './types/idx-js';\nimport {\n  isTerminalResponse,\n  filterValuesForRemediation,\n  getRemediator,\n  getNextStep,\n  handleIdxError\n} from './util';\n\nexport interface RemediateActionWithOptionalParams {\n  name: string;\n  params?: IdxActionParams;\n}\n\nexport type RemediateAction = string | RemediateActionWithOptionalParams;\n\n\nfunction getActionFromValues(values: RemediationValues, idxResponse: IdxResponse): string | undefined {\n  // Currently support resend actions only\n  return Object.keys(idxResponse.actions).find(action => !!values.resend && action.includes('-resend'));\n}\n\nfunction removeActionFromValues(values: RemediationValues): RemediationValues {\n  // Currently support resend actions only\n  return {\n    ...values,\n    resend: undefined\n  };\n}\n\nfunction removeActionFromOptions(options: RemediateOptions, actionName: string): RemediateOptions {\n  let actions = options.actions || [];\n  actions = actions.filter(entry => {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n    return entry.name !== actionName;\n  });\n\n  return { ...options, actions };\n}\n\n// This function is called recursively until it reaches success or cannot be remediated\nexport async function remediate(\n  authClient: OktaAuthIdxInterface,\n  idxResponse: IdxResponse,\n  values: RemediationValues,\n  options: RemediateOptions\n): Promise<RemediationResponse> {\n  let { neededToProceed, interactionCode } = idxResponse;\n  const { flow } = options;\n\n  // If the response contains an interaction code, there is no need to remediate\n  if (interactionCode) {\n    return { idxResponse };\n  }\n\n  const remediator = getRemediator(neededToProceed, values, options);\n\n  // Try actions in idxResponse first\n  const actionFromValues = getActionFromValues(values, idxResponse);\n  const actionFromOptions = options.actions || [];\n  const actions = [\n    ...actionFromOptions,\n    ...(actionFromValues && [actionFromValues] || []),\n  ];\n  if (actions) {\n    for (let action of actions) {\n      // Action can either be specified as a string, or as an object with name and optional params\n      let params: IdxActionParams = {};\n      if (typeof action !== 'string') {\n        params = action.params || {};\n        action = action.name;\n      }\n      let valuesWithoutExecutedAction = removeActionFromValues(values);\n      let optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n\n      if (typeof idxResponse.actions[action] === 'function') {\n        try {\n          idxResponse = await idxResponse.actions[action](params);\n          idxResponse = { ...idxResponse, requestDidSucceed: true };\n        } catch (e) {\n          return handleIdxError(authClient, e, options);\n        }\n        if (action === 'cancel') {\n          return { idxResponse, canceled: true };\n        }\n        return remediate(\n          authClient, \n          idxResponse, \n          valuesWithoutExecutedAction, \n          optionsWithoutExecutedAction\n        ); // recursive call\n      }\n\n      // search for action in remediation list\n      const remediationAction = neededToProceed.find(({ name }) => name === action);\n      if (remediationAction) {\n        try {\n          idxResponse = await idxResponse.proceed(action, params);\n          idxResponse = { ...idxResponse, requestDidSucceed: true };\n        }\n        catch (e) {\n          return handleIdxError(authClient, e, options);\n        }\n\n        return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction); // recursive call\n      }\n    }\n  }\n\n  // Do not attempt to remediate if response is in terminal state\n  const terminal = isTerminalResponse(idxResponse);\n  if (terminal) {\n    return { idxResponse, terminal };\n  }\n\n  if (!remediator) {\n    if (options.step) {\n      values = filterValuesForRemediation(idxResponse, options.step, values); // include only requested values\n      try {\n        idxResponse = await idxResponse.proceed(options.step, values);\n        idxResponse = { ...idxResponse, requestDidSucceed: true };\n        return { idxResponse };\n      } catch(e) {\n        return handleIdxError(authClient, e, options);\n      }\n    }\n    if (flow === 'default') {\n      return { idxResponse };\n    }\n    throw new AuthSdkError(`\n      No remediation can match current flow, check policy settings in your org.\n      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + ' ,' + curr.name : curr.name, '')}]\n    `);\n  }\n\n  // Return next step to the caller\n  if (!remediator.canRemediate()) {\n    const nextStep = getNextStep(authClient, remediator, idxResponse);\n    return {\n      idxResponse,\n      nextStep,\n    };\n  }\n\n  const name = remediator.getName();\n  const data = remediator.getData();\n  try {\n    idxResponse = await idxResponse.proceed(name, data);\n    idxResponse = { ...idxResponse, requestDidSucceed: true };\n    // We may want to trim the values bag for the next remediation\n    // Let the remediator decide what the values should be (default to current values)\n    values = remediator.getValuesAfterProceed();\n    options = { ...options, step: undefined }; // do not re-use the step\n\n    // generic remediator should not auto proceed in pending status\n    // return nextStep directly\n    if (options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const gr = getRemediator(idxResponse.neededToProceed, values, options)!;\n      const nextStep = getNextStep(authClient, gr, idxResponse);\n      return {\n        idxResponse,\n        nextStep,\n      };\n    }\n    \n    return remediate(authClient, idxResponse, values, options); // recursive call\n  } catch (e) {\n    return handleIdxError(authClient, e, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}