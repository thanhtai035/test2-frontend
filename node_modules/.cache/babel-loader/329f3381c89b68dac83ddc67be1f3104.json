{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ADMIN/Downloads/okta-springboot-react-master/okta-springboot-react-master/test2/test2-s3760615-front-end/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { removeNils, clone } from './util/object.js';\nimport AuthSdkError from './errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from './features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants.js';\nimport { validateToken as _validateToken } from './oidc/util/validateToken.js';\nimport SdkClock from './clock.js';\nimport './idx/types/api.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nimport './myaccount/types.js';\nvar DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\n\nvar TokenManager = /*#__PURE__*/function () {\n  function TokenManager(sdk) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TokenManager);\n\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n    var storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n\n  _createClass(TokenManager, [{\n    key: \"on\",\n    value: function on(event, handler, context) {\n      if (context) {\n        this.emitter.on(event, handler, context);\n      } else {\n        this.emitter.on(event, handler);\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      if (handler) {\n        this.emitter.off(event, handler);\n      } else {\n        this.emitter.off(event);\n      }\n    }\n  }, {\n    key: \"hasSharedStorage\",\n    value: function hasSharedStorage() {\n      return this.storage.isSharedStorage();\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.options.clearPendingRemoveTokens) {\n        this.clearPendingRemoveTokens();\n      }\n\n      this.setExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.clearExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return clone(this.options);\n    }\n  }, {\n    key: \"getExpireTime\",\n    value: function getExpireTime(token) {\n      var expireEarlySeconds = this.options.expireEarlySeconds || 0;\n      var expireTime = token.expiresAt - expireEarlySeconds;\n      return expireTime;\n    }\n  }, {\n    key: \"hasExpired\",\n    value: function hasExpired(token) {\n      var expireTime = this.getExpireTime(token);\n      return expireTime <= this.clock.now();\n    }\n  }, {\n    key: \"emitExpired\",\n    value: function emitExpired(key, token) {\n      this.emitter.emit(EVENT_EXPIRED, key, token);\n    }\n  }, {\n    key: \"emitRenewed\",\n    value: function emitRenewed(key, freshToken, oldToken) {\n      this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n    }\n  }, {\n    key: \"emitAdded\",\n    value: function emitAdded(key, token) {\n      this.emitter.emit(EVENT_ADDED, key, token);\n    }\n  }, {\n    key: \"emitRemoved\",\n    value: function emitRemoved(key, token) {\n      this.emitter.emit(EVENT_REMOVED, key, token);\n    }\n  }, {\n    key: \"emitError\",\n    value: function emitError(error) {\n      this.emitter.emit(EVENT_ERROR, error);\n    }\n  }, {\n    key: \"clearExpireEventTimeout\",\n    value: function clearExpireEventTimeout(key) {\n      clearTimeout(this.state.expireTimeouts[key]);\n      delete this.state.expireTimeouts[key];\n      this.state.renewPromise = null;\n    }\n  }, {\n    key: \"clearExpireEventTimeoutAll\",\n    value: function clearExpireEventTimeoutAll() {\n      var expireTimeouts = this.state.expireTimeouts;\n\n      for (var key in expireTimeouts) {\n        if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n          continue;\n        }\n\n        this.clearExpireEventTimeout(key);\n      }\n    }\n  }, {\n    key: \"setExpireEventTimeout\",\n    value: function setExpireEventTimeout(key, token) {\n      var _this = this;\n\n      if (isRefreshToken(token)) {\n        return;\n      }\n\n      var expireTime = this.getExpireTime(token);\n      var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n      this.clearExpireEventTimeout(key);\n      var expireEventTimeout = setTimeout(function () {\n        _this.emitExpired(key, token);\n      }, expireEventWait);\n      this.state.expireTimeouts[key] = expireEventTimeout;\n    }\n  }, {\n    key: \"setExpireEventTimeoutAll\",\n    value: function setExpireEventTimeoutAll() {\n      var tokenStorage = this.storage.getStorage();\n\n      for (var key in tokenStorage) {\n        if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n          continue;\n        }\n\n        var token = tokenStorage[key];\n        this.setExpireEventTimeout(key, token);\n      }\n    }\n  }, {\n    key: \"resetExpireEventTimeoutAll\",\n    value: function resetExpireEventTimeoutAll() {\n      this.clearExpireEventTimeoutAll();\n      this.setExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, token) {\n      var tokenStorage = this.storage.getStorage();\n\n      _validateToken(token);\n\n      tokenStorage[key] = token;\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n    }\n  }, {\n    key: \"getSync\",\n    value: function getSync(key) {\n      var tokenStorage = this.storage.getStorage();\n      return tokenStorage[key];\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.getSync(key));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"getTokensSync\",\n    value: function getTokensSync() {\n      var tokens = {};\n      var tokenStorage = this.storage.getStorage();\n      Object.keys(tokenStorage).forEach(function (key) {\n        var token = tokenStorage[key];\n\n        if (isAccessToken(token)) {\n          tokens.accessToken = token;\n        } else if (isIDToken(token)) {\n          tokens.idToken = token;\n        } else if (isRefreshToken(token)) {\n          tokens.refreshToken = token;\n        }\n      });\n      return tokens;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function () {\n      var _getTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.getTokensSync());\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getTokens() {\n        return _getTokens.apply(this, arguments);\n      }\n\n      return getTokens;\n    }()\n  }, {\n    key: \"getStorageKeyByType\",\n    value: function getStorageKeyByType(type) {\n      var tokenStorage = this.storage.getStorage();\n      var key = Object.keys(tokenStorage).filter(function (key) {\n        var token = tokenStorage[key];\n        return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n      })[0];\n      return key;\n    }\n  }, {\n    key: \"getTokenType\",\n    value: function getTokenType(token) {\n      if (isAccessToken(token)) {\n        return 'accessToken';\n      }\n\n      if (isIDToken(token)) {\n        return 'idToken';\n      }\n\n      if (isRefreshToken(token)) {\n        return 'refreshToken';\n      }\n\n      throw new AuthSdkError('Unknown token type');\n    }\n  }, {\n    key: \"emitSetStorageEvent\",\n    value: function emitSetStorageEvent() {\n      if (isIE11OrLess()) {\n        var storage = this.storage.getStorage();\n        this.emitter.emit(EVENT_SET_STORAGE, storage);\n      }\n    }\n  }, {\n    key: \"getStorage\",\n    value: function getStorage() {\n      return this.storage;\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n      var _this2 = this;\n\n      var handleTokenCallback = function handleTokenCallback(key, token) {\n        var type = _this2.getTokenType(token);\n\n        if (type === 'accessToken') {\n          accessTokenCb && accessTokenCb(key, token);\n        } else if (type === 'idToken') {\n          idTokenCb && idTokenCb(key, token);\n        } else if (type === 'refreshToken') {\n          refreshTokenCb && refreshTokenCb(key, token);\n        }\n      };\n\n      var handleAdded = function handleAdded(key, token) {\n        _this2.emitAdded(key, token);\n\n        _this2.setExpireEventTimeout(key, token);\n\n        handleTokenCallback(key, token);\n      };\n\n      var handleRenewed = function handleRenewed(key, token, oldToken) {\n        _this2.emitRenewed(key, token, oldToken);\n\n        _this2.clearExpireEventTimeout(key);\n\n        _this2.setExpireEventTimeout(key, token);\n\n        handleTokenCallback(key, token);\n      };\n\n      var handleRemoved = function handleRemoved(key, token) {\n        _this2.clearExpireEventTimeout(key);\n\n        _this2.emitRemoved(key, token);\n\n        handleTokenCallback(key, token);\n      };\n\n      var types = ['idToken', 'accessToken', 'refreshToken'];\n      var existingTokens = this.getTokensSync();\n      types.forEach(function (type) {\n        var token = tokens[type];\n\n        if (token) {\n          _validateToken(token, type);\n        }\n      });\n      var storage = types.reduce(function (storage, type) {\n        var token = tokens[type];\n\n        if (token) {\n          var storageKey = _this2.getStorageKeyByType(type) || type;\n          storage[storageKey] = token;\n        }\n\n        return storage;\n      }, {});\n      this.storage.setStorage(storage);\n      this.emitSetStorageEvent();\n      types.forEach(function (type) {\n        var newToken = tokens[type];\n        var existingToken = existingTokens[type];\n        var storageKey = _this2.getStorageKeyByType(type) || type;\n\n        if (newToken && existingToken) {\n          handleRemoved(storageKey, existingToken);\n          handleAdded(storageKey, newToken);\n          handleRenewed(storageKey, newToken, existingToken);\n        } else if (newToken) {\n          handleAdded(storageKey, newToken);\n        } else if (existingToken) {\n          handleRemoved(storageKey, existingToken);\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      this.clearExpireEventTimeout(key);\n      var tokenStorage = this.storage.getStorage();\n      var removedToken = tokenStorage[key];\n      delete tokenStorage[key];\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      this.emitRemoved(key, removedToken);\n    }\n  }, {\n    key: \"renewToken\",\n    value: function () {\n      var _renewToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token) {\n        var _a;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function renewToken(_x2) {\n        return _renewToken.apply(this, arguments);\n      }\n\n      return renewToken;\n    }()\n  }, {\n    key: \"validateToken\",\n    value: function validateToken(token) {\n      return _validateToken(token);\n    }\n  }, {\n    key: \"renew\",\n    value: function renew(key) {\n      var _this3 = this;\n\n      if (this.state.renewPromise) {\n        return this.state.renewPromise;\n      }\n\n      try {\n        var token = this.getSync(key);\n\n        if (!token) {\n          throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      this.clearExpireEventTimeout(key);\n      this.state.renewPromise = this.sdk.token.renewTokens().then(function (tokens) {\n        _this3.setTokens(tokens);\n\n        var tokenType = _this3.getTokenType(token);\n\n        return tokens[tokenType];\n      }).catch(function (err) {\n        _this3.remove(key);\n\n        err.tokenKey = key;\n\n        _this3.emitError(err);\n\n        throw err;\n      }).finally(function () {\n        _this3.state.renewPromise = null;\n      });\n      return this.state.renewPromise;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this4 = this;\n\n      var tokens = this.getTokensSync();\n      this.clearExpireEventTimeoutAll();\n      this.storage.clearStorage();\n      this.emitSetStorageEvent();\n      Object.keys(tokens).forEach(function (key) {\n        _this4.emitRemoved(key, tokens[key]);\n      });\n    }\n  }, {\n    key: \"clearPendingRemoveTokens\",\n    value: function clearPendingRemoveTokens() {\n      var _this5 = this;\n\n      var tokenStorage = this.storage.getStorage();\n      var removedTokens = {};\n      Object.keys(tokenStorage).forEach(function (key) {\n        if (tokenStorage[key].pendingRemove) {\n          removedTokens[key] = tokenStorage[key];\n          delete tokenStorage[key];\n        }\n      });\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      Object.keys(removedTokens).forEach(function (key) {\n        _this5.clearExpireEventTimeout(key);\n\n        _this5.emitRemoved(key, removedTokens[key]);\n      });\n    }\n  }, {\n    key: \"updateRefreshToken\",\n    value: function updateRefreshToken(token) {\n      var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n      var tokenStorage = this.storage.getStorage();\n\n      _validateToken(token);\n\n      tokenStorage[key] = token;\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n    }\n  }, {\n    key: \"removeRefreshToken\",\n    value: function removeRefreshToken() {\n      var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n      this.remove(key);\n    }\n  }, {\n    key: \"addPendingRemoveFlags\",\n    value: function addPendingRemoveFlags() {\n      var tokens = this.getTokensSync();\n      Object.keys(tokens).forEach(function (key) {\n        tokens[key].pendingRemove = true;\n      });\n      this.setTokens(tokens);\n    }\n  }]);\n\n  return TokenManager;\n}();\n\nexport { TokenManager };","map":{"version":3,"mappings":"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","names":["DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","TOKEN_STORAGE_NAME","defaultState","expireTimeouts","renewPromise","TokenManager","sdk","options","emitter","AuthSdkError","Object","assign","removeNils","isLocalhost","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","SdkClock","create","state","event","handler","context","on","off","isSharedStorage","setExpireEventTimeoutAll","clearExpireEventTimeoutAll","clone","token","expireTime","expiresAt","getExpireTime","now","key","emit","EVENT_EXPIRED","freshToken","oldToken","EVENT_RENEWED","EVENT_ADDED","EVENT_REMOVED","error","EVENT_ERROR","clearTimeout","prototype","hasOwnProperty","call","clearExpireEventTimeout","isRefreshToken","expireEventWait","Math","max","expireEventTimeout","setTimeout","emitExpired","tokenStorage","getStorage","setExpireEventTimeout","validateToken","setStorage","emitSetStorageEvent","emitAdded","getSync","tokens","keys","forEach","isAccessToken","accessToken","isIDToken","idToken","refreshToken","getTokensSync","type","filter","isIE11OrLess","EVENT_SET_STORAGE","accessTokenCb","idTokenCb","refreshTokenCb","handleTokenCallback","getTokenType","handleAdded","handleRenewed","emitRenewed","handleRemoved","emitRemoved","types","existingTokens","reduce","getStorageKeyByType","newToken","existingToken","removedToken","_a","renew","e","Promise","reject","renewTokens","then","setTokens","tokenType","catch","remove","err","tokenKey","emitError","finally","clearStorage","removedTokens","pendingRemove","REFRESH_TOKEN_STORAGE_KEY"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\TokenManager.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { removeNils, clone } from './util';\nimport { AuthSdkError } from './errors';\nimport { validateToken  } from './oidc/util';\nimport { isLocalhost, isIE11OrLess } from './features';\nimport SdkClock from './clock';\nimport {\n  EventEmitter,\n  Token, \n  Tokens, \n  TokenType, \n  TokenManagerOptions, \n  isIDToken, \n  isAccessToken,\n  isRefreshToken,\n  StorageOptions,\n  StorageType,\n  OktaAuthInterface,\n  StorageProvider,\n  TokenManagerErrorEventHandler,\n  TokenManagerSetStorageEventHandler,\n  TokenManagerRenewEventHandler,\n  TokenManagerEventHandler,\n  TokenManagerInterface,\n  RefreshToken,\n  AccessTokenCallback,\n  IDTokenCallback,\n  RefreshTokenCallback,\n  EVENT_RENEWED,\n  EVENT_ADDED,\n  EVENT_ERROR,\n  EVENT_EXPIRED,\n  EVENT_REMOVED,\n  EVENT_SET_STORAGE,\n  TokenManagerAnyEventHandler,\n  TokenManagerAnyEvent\n} from './types';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants';\n\nconst DEFAULT_OPTIONS = {\n  // TODO: remove in next major version - OKTA-473815\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  // --- //\n  clearPendingRemoveTokens: true,\n  storage: undefined, // will use value from storageManager config\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\ninterface TokenManagerState {\n  expireTimeouts: Record<string, unknown>;\n  renewPromise: Promise<Token | undefined> | null;\n}\nfunction defaultState(): TokenManagerState {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nexport class TokenManager implements TokenManagerInterface {\n  private sdk: OktaAuthInterface;\n  private clock: SdkClock;\n  private emitter: EventEmitter;\n  private storage: StorageProvider;\n  private state: TokenManagerState;\n  private options: TokenManagerOptions;\n\n  on(event: typeof EVENT_RENEWED, handler: TokenManagerRenewEventHandler, context?: object): void;\n  on(event: typeof EVENT_ERROR, handler: TokenManagerErrorEventHandler, context?: object): void;\n  on(event: typeof EVENT_SET_STORAGE, handler: TokenManagerSetStorageEventHandler, context?: object): void;\n  on(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler: TokenManagerEventHandler, context?: object): void;\n  on(event: TokenManagerAnyEvent, handler: TokenManagerAnyEventHandler, context?: object): void {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event: typeof EVENT_RENEWED, handler?: TokenManagerRenewEventHandler): void;\n  off(event: typeof EVENT_ERROR, handler?: TokenManagerErrorEventHandler): void;\n  off(event: typeof EVENT_SET_STORAGE, handler?: TokenManagerSetStorageEventHandler): void;\n  off(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler?: TokenManagerEventHandler): void;\n  off(event: TokenManagerAnyEvent, handler?: TokenManagerAnyEventHandler): void {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  constructor(sdk: OktaAuthInterface, options: TokenManagerOptions = {}) {\n    this.sdk = sdk;\n    this.emitter = (sdk as any).emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    \n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n\n    const storageOptions: StorageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure,\n    });\n    if (typeof options.storage === 'object') {\n      // A custom storage provider must implement getItem(key) and setItem(key, val)\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage as StorageType;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage({...storageOptions, useSeparateCookies: true});\n    this.clock = SdkClock.create(/* sdk, options */);\n    this.state = defaultState();\n  }\n\n  hasSharedStorage() {\n    return this.storage.isSharedStorage();\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n  }\n  \n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n\n  getOptions(): TokenManagerOptions {\n    return clone(this.options);\n  }\n  \n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  \n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  \n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  \n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  \n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  \n  emitRemoved(key, token?) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  \n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  \n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key] as any);\n    delete this.state.expireTimeouts[key];\n  \n    // Remove the renew promise (if it exists)\n    this.state.renewPromise = null;\n  }\n  \n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  \n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n  \n    // Clear any existing timeout\n    this.clearExpireEventTimeout(key);\n  \n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n  \n    // Add a new timeout\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  \n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for(var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  \n  // reset timeouts to setup autoRenew for tokens from other document context (tabs)\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  \n  add(key, token: Token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  \n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  \n  async get(key) {\n    return this.getSync(key);\n  }\n  \n  getTokensSync(): Tokens {\n    const tokens = {} as Tokens;\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) { \n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  \n  async getTokens(): Promise<Tokens> {\n    return this.getTokensSync();\n  }\n\n  getStorageKeyByType(type: TokenType): string {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return (isAccessToken(token) && type === 'accessToken') \n        || (isIDToken(token) && type === 'idToken')\n        || (isRefreshToken(token) && type === 'refreshToken');\n    })[0];\n    return key;\n  }\n\n  private getTokenType(token: Token): TokenType {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if(isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  // for synchronization of LocalStorage cross tabs for IE11\n  private emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  // used in `SyncStorageService` for synchronization of LocalStorage cross tabs for IE11\n  public getStorage() {\n    return this.storage;\n  }\n\n  setTokens(\n    tokens: Tokens,\n    // TODO: callbacks can be removed in the next major version OKTA-407224\n    accessTokenCb?: AccessTokenCallback, \n    idTokenCb?: IDTokenCallback,\n    refreshTokenCb?: RefreshTokenCallback\n  ): void {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    \n    const types: TokenType[] = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n\n    // valid tokens\n    types.forEach((type) => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n  \n    // add token to storage\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n\n    // emit event and start expiration timer\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) { // renew\n        // call handleRemoved first, since it clears timers\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) { // add\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) { //remove\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  \n  remove(key) {\n    // Clear any listener for this token\n    this.clearExpireEventTimeout(key);\n  \n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  \n    this.emitRemoved(key, removedToken);\n  }\n  \n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  async renewToken(token) {\n    return this.sdk.token?.renew(token);\n  }\n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  validateToken(token: Token) {\n    return validateToken(token);\n  }\n\n  // TODO: renew method should take no param, change in the next major version OKTA-407224\n  renew(key): Promise<Token | undefined> {\n    // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n  \n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  \n    // Remove existing autoRenew timeout\n    this.clearExpireEventTimeout(key);\n  \n    // A refresh token means a replace instead of renewal\n    // Store the renew promise state, to avoid renewing again\n    this.state.renewPromise = this.sdk.token.renewTokens()\n      .then(tokens => {\n        this.setTokens(tokens);\n\n        // resolve token based on the key\n        const tokenType = this.getTokenType(token);\n        return tokens[tokenType];\n      })\n      .catch(err => {\n        // If renew fails, remove token from storage and emit error\n        this.remove(key);\n        err.tokenKey = key;\n        this.emitError(err);\n        throw err;\n      })\n      .finally(() => {\n        // Remove existing promise key\n        this.state.renewPromise = null;\n      });\n  \n    return this.state.renewPromise;\n  }\n  \n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token: RefreshToken) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n\n    // do not emit any event\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken () {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n  \n}\n"]},"metadata":{},"sourceType":"module"}