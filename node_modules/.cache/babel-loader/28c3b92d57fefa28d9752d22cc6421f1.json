{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { removeNils, clone } from './util/object.js';\nimport AuthSdkError from './errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from './features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants.js';\nimport { validateToken } from './oidc/util/validateToken.js';\nimport SdkClock from './clock.js';\nimport './idx/types/api.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nimport './myaccount/types.js';\nconst DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\n\nclass TokenManager {\n  constructor(sdk) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n    const storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n\n  on(event, handler, context) {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event, handler) {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  hasSharedStorage() {\n    return this.storage.isSharedStorage();\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n\n    this.setExpireEventTimeoutAll();\n  }\n\n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n\n  getOptions() {\n    return clone(this.options);\n  }\n\n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n\n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n\n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n\n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n\n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n\n  emitRemoved(key, token) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n\n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n\n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key]);\n    delete this.state.expireTimeouts[key];\n    this.state.renewPromise = null;\n  }\n\n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n\n      this.clearExpireEventTimeout(key);\n    }\n  }\n\n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n    this.clearExpireEventTimeout(key);\n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n\n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n\n    for (var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n\n  add(key, token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n\n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n\n  async get(key) {\n    return this.getSync(key);\n  }\n\n  getTokensSync() {\n    const tokens = {};\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) {\n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n\n  async getTokens() {\n    return this.getTokensSync();\n  }\n\n  getStorageKeyByType(type) {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n    })[0];\n    return key;\n  }\n\n  getTokenType(token) {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n\n    if (isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  getStorage() {\n    return this.storage;\n  }\n\n  setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const types = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n    types.forEach(type => {\n      const token = tokens[type];\n\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n\n      if (newToken && existingToken) {\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) {\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) {\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n\n  remove(key) {\n    this.clearExpireEventTimeout(key);\n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitRemoved(key, removedToken);\n  }\n\n  async renewToken(token) {\n    var _a;\n\n    return (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n  }\n\n  validateToken(token) {\n    return validateToken(token);\n  }\n\n  renew(key) {\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n\n    try {\n      var token = this.getSync(key);\n\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    this.clearExpireEventTimeout(key);\n    this.state.renewPromise = this.sdk.token.renewTokens().then(tokens => {\n      this.setTokens(tokens);\n      const tokenType = this.getTokenType(token);\n      return tokens[tokenType];\n    }).catch(err => {\n      this.remove(key);\n      err.tokenKey = key;\n      this.emitError(err);\n      throw err;\n    }).finally(() => {\n      this.state.renewPromise = null;\n    });\n    return this.state.renewPromise;\n  }\n\n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken() {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n\n}\n\nexport { TokenManager };","map":{"version":3,"mappings":"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","names":["DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","TOKEN_STORAGE_NAME","defaultState","expireTimeouts","renewPromise","TokenManager","constructor","options","sdk","emitter","AuthSdkError","Object","assign","removeNils","isLocalhost","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","SdkClock","create","state","on","event","handler","context","off","hasSharedStorage","isSharedStorage","start","setExpireEventTimeoutAll","stop","clearExpireEventTimeoutAll","getOptions","clone","getExpireTime","token","expireTime","expiresAt","hasExpired","now","emitExpired","key","emit","EVENT_EXPIRED","emitRenewed","freshToken","oldToken","EVENT_RENEWED","emitAdded","EVENT_ADDED","emitRemoved","EVENT_REMOVED","emitError","error","EVENT_ERROR","clearExpireEventTimeout","clearTimeout","prototype","hasOwnProperty","call","setExpireEventTimeout","isRefreshToken","expireEventWait","Math","max","expireEventTimeout","setTimeout","tokenStorage","getStorage","resetExpireEventTimeoutAll","add","validateToken","setStorage","emitSetStorageEvent","getSync","get","getTokensSync","tokens","keys","forEach","isAccessToken","accessToken","isIDToken","idToken","refreshToken","getTokens","getStorageKeyByType","type","filter","getTokenType","isIE11OrLess","EVENT_SET_STORAGE","setTokens","accessTokenCb","idTokenCb","refreshTokenCb","handleTokenCallback","handleAdded","handleRenewed","handleRemoved","types","existingTokens","reduce","newToken","existingToken","remove","removedToken","renewToken","_a","renew","e","Promise","reject","renewTokens","then","tokenType","catch","err","tokenKey","finally","clear","clearStorage","removedTokens","pendingRemove","updateRefreshToken","REFRESH_TOKEN_STORAGE_KEY","removeRefreshToken","addPendingRemoveFlags"],"sources":["C:\\Users\\ADMIN\\Downloads\\okta-springboot-react-master\\okta-springboot-react-master\\test2\\test2-s3760615-front-end\\node_modules\\@okta\\lib\\TokenManager.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { removeNils, clone } from './util';\nimport { AuthSdkError } from './errors';\nimport { validateToken  } from './oidc/util';\nimport { isLocalhost, isIE11OrLess } from './features';\nimport SdkClock from './clock';\nimport {\n  EventEmitter,\n  Token, \n  Tokens, \n  TokenType, \n  TokenManagerOptions, \n  isIDToken, \n  isAccessToken,\n  isRefreshToken,\n  StorageOptions,\n  StorageType,\n  OktaAuthInterface,\n  StorageProvider,\n  TokenManagerErrorEventHandler,\n  TokenManagerSetStorageEventHandler,\n  TokenManagerRenewEventHandler,\n  TokenManagerEventHandler,\n  TokenManagerInterface,\n  RefreshToken,\n  AccessTokenCallback,\n  IDTokenCallback,\n  RefreshTokenCallback,\n  EVENT_RENEWED,\n  EVENT_ADDED,\n  EVENT_ERROR,\n  EVENT_EXPIRED,\n  EVENT_REMOVED,\n  EVENT_SET_STORAGE,\n  TokenManagerAnyEventHandler,\n  TokenManagerAnyEvent\n} from './types';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants';\n\nconst DEFAULT_OPTIONS = {\n  // TODO: remove in next major version - OKTA-473815\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  // --- //\n  clearPendingRemoveTokens: true,\n  storage: undefined, // will use value from storageManager config\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\ninterface TokenManagerState {\n  expireTimeouts: Record<string, unknown>;\n  renewPromise: Promise<Token | undefined> | null;\n}\nfunction defaultState(): TokenManagerState {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nexport class TokenManager implements TokenManagerInterface {\n  private sdk: OktaAuthInterface;\n  private clock: SdkClock;\n  private emitter: EventEmitter;\n  private storage: StorageProvider;\n  private state: TokenManagerState;\n  private options: TokenManagerOptions;\n\n  on(event: typeof EVENT_RENEWED, handler: TokenManagerRenewEventHandler, context?: object): void;\n  on(event: typeof EVENT_ERROR, handler: TokenManagerErrorEventHandler, context?: object): void;\n  on(event: typeof EVENT_SET_STORAGE, handler: TokenManagerSetStorageEventHandler, context?: object): void;\n  on(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler: TokenManagerEventHandler, context?: object): void;\n  on(event: TokenManagerAnyEvent, handler: TokenManagerAnyEventHandler, context?: object): void {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event: typeof EVENT_RENEWED, handler?: TokenManagerRenewEventHandler): void;\n  off(event: typeof EVENT_ERROR, handler?: TokenManagerErrorEventHandler): void;\n  off(event: typeof EVENT_SET_STORAGE, handler?: TokenManagerSetStorageEventHandler): void;\n  off(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler?: TokenManagerEventHandler): void;\n  off(event: TokenManagerAnyEvent, handler?: TokenManagerAnyEventHandler): void {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  constructor(sdk: OktaAuthInterface, options: TokenManagerOptions = {}) {\n    this.sdk = sdk;\n    this.emitter = (sdk as any).emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    \n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n\n    const storageOptions: StorageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure,\n    });\n    if (typeof options.storage === 'object') {\n      // A custom storage provider must implement getItem(key) and setItem(key, val)\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage as StorageType;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage({...storageOptions, useSeparateCookies: true});\n    this.clock = SdkClock.create(/* sdk, options */);\n    this.state = defaultState();\n  }\n\n  hasSharedStorage() {\n    return this.storage.isSharedStorage();\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n  }\n  \n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n\n  getOptions(): TokenManagerOptions {\n    return clone(this.options);\n  }\n  \n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  \n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  \n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  \n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  \n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  \n  emitRemoved(key, token?) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  \n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  \n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key] as any);\n    delete this.state.expireTimeouts[key];\n  \n    // Remove the renew promise (if it exists)\n    this.state.renewPromise = null;\n  }\n  \n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  \n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n  \n    // Clear any existing timeout\n    this.clearExpireEventTimeout(key);\n  \n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n  \n    // Add a new timeout\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  \n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for(var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  \n  // reset timeouts to setup autoRenew for tokens from other document context (tabs)\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  \n  add(key, token: Token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  \n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  \n  async get(key) {\n    return this.getSync(key);\n  }\n  \n  getTokensSync(): Tokens {\n    const tokens = {} as Tokens;\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) { \n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  \n  async getTokens(): Promise<Tokens> {\n    return this.getTokensSync();\n  }\n\n  getStorageKeyByType(type: TokenType): string {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return (isAccessToken(token) && type === 'accessToken') \n        || (isIDToken(token) && type === 'idToken')\n        || (isRefreshToken(token) && type === 'refreshToken');\n    })[0];\n    return key;\n  }\n\n  private getTokenType(token: Token): TokenType {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if(isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  // for synchronization of LocalStorage cross tabs for IE11\n  private emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  // used in `SyncStorageService` for synchronization of LocalStorage cross tabs for IE11\n  public getStorage() {\n    return this.storage;\n  }\n\n  setTokens(\n    tokens: Tokens,\n    // TODO: callbacks can be removed in the next major version OKTA-407224\n    accessTokenCb?: AccessTokenCallback, \n    idTokenCb?: IDTokenCallback,\n    refreshTokenCb?: RefreshTokenCallback\n  ): void {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    \n    const types: TokenType[] = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n\n    // valid tokens\n    types.forEach((type) => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n  \n    // add token to storage\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n\n    // emit event and start expiration timer\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) { // renew\n        // call handleRemoved first, since it clears timers\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) { // add\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) { //remove\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  \n  remove(key) {\n    // Clear any listener for this token\n    this.clearExpireEventTimeout(key);\n  \n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  \n    this.emitRemoved(key, removedToken);\n  }\n  \n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  async renewToken(token) {\n    return this.sdk.token?.renew(token);\n  }\n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  validateToken(token: Token) {\n    return validateToken(token);\n  }\n\n  // TODO: renew method should take no param, change in the next major version OKTA-407224\n  renew(key): Promise<Token | undefined> {\n    // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n  \n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  \n    // Remove existing autoRenew timeout\n    this.clearExpireEventTimeout(key);\n  \n    // A refresh token means a replace instead of renewal\n    // Store the renew promise state, to avoid renewing again\n    this.state.renewPromise = this.sdk.token.renewTokens()\n      .then(tokens => {\n        this.setTokens(tokens);\n\n        // resolve token based on the key\n        const tokenType = this.getTokenType(token);\n        return tokens[tokenType];\n      })\n      .catch(err => {\n        // If renew fails, remove token from storage and emit error\n        this.remove(key);\n        err.tokenKey = key;\n        this.emitError(err);\n        throw err;\n      })\n      .finally(() => {\n        // Remove existing promise key\n        this.state.renewPromise = null;\n      });\n  \n    return this.state.renewPromise;\n  }\n  \n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token: RefreshToken) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n\n    // do not emit any event\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken () {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n  \n}\n"]},"metadata":{},"sourceType":"module"}